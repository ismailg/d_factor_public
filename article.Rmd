---
title: "The Price of Dark Traits: Strategic Exploitation and Its Limitations in Repeated Trust Games"
author: ""
bibliography: "bib/DFP2.bib"
date: "`r Sys.Date()`"
output: 
  bookdown::pdf_document2:
    latex_engine: xelatex
    keep_tex: true
    toc: false
header-includes:
  - \usepackage{pdflscape}
  - \usepackage{graphicx}
  # --- Additions for line spacing and numbering ---
  - \usepackage{setspace}   # Package for controlling line spacing
  - \usepackage{lineno}     # Package for line numbers. 
  - \doublespacing         # Sets document to double-spaced. Use \onehalfspacing for 1.5 spacing.
  - \linenumbers           # Command to activate line numbering.
---


**Abstract:**

Trust and cooperation are fundamental to human social interaction, with personality traits significantly influencing economic decision-making. This study introduces a novel approach using adaptive computational agents to provide the first examination of how the Dark Factor of Personality (D-factor)—the unifying core of malevolent traits—affects trustworthiness and strategic exploitation in dynamic, repeated trust games. After pre-screening 1,243 participants, we selected individuals with high and low D-factor scores. Participants (N=183) played two 25-round trust games as trustees against programmed Hidden Markov Model (HMM) investors derived from human data but differing in strategic reactivity: one 'human-like' HMM exhibited a characteristic 'sticky' mid-trust state (potentially vulnerable to exploitation), while a 'responsive' HMM reacted more decisively and immediately to trustee returns. Consistent with the D-factor concept, high-D participants returned lower proportions, particularly later in the interactions. High-D individuals also demonstrated sophisticated strategic adaptation, significantly decreasing reciprocity over time only when receiving high investments from the more passively exploitable 'human-like' opponent. Crucially, this exploitative strategy proved self-limiting: high-D participants did not achieve higher total payoffs overall, as the 'responsive' HMM adaptively reduced investments. These findings uniquely demonstrate how D-factor manifests strategically in dynamic exchanges and reveal the critical role of opponent responsiveness in constraining exploitation, highlighting both the sophistication and the boundaries of dark personality expression in social interactions.

\vspace{1cm}

**Keywords** : Interpersonal functioning; Dark Factor of Personality; Strategic exploitation; Trust-based Cooperation; Hidden Markov Models




\pagebreak



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, include=FALSE, warning = FALSE)
```


# Introduction 


Trust and cooperation are fundamental to human social interaction and economic exchange [@OstromWalker2003; @Yamagishi2011]. The trust game, introduced by @Berg1995, provides a powerful and widely adopted tool for investigating the dynamics of trust and trustworthiness in controlled settings [@Camerer2003; @JohnsonMislin2011]. 

While situational factors influence behavior, stable individual differences in personality traits are also significant predictors [@EvansRevelle2008; @MullerSchwieren2020]. Among the most potent predictors of antisocial or self-interested behavior are the "dark" personality traits. Although often studied via the Dark Triad framework (Machiavellianism, Narcissism, Psychopathy; @PaulhusWilliams2002), the considerable overlap between these traits [@Zettler2021] spurred the development of the Dark Factor of Personality (D-factor) [@Moshagen2018]. Proposed as the common core underlying various malevolent traits, D is defined as "the general tendency to maximize one's utility at the expense of others, accompanied by beliefs that serve as justifications" [@Moshagen2018]. This unifying construct, incorporating elements like Machiavellianism and Psychopathy previously linked to reduced trustworthiness [@Ibanez2016; @Gunnthorsdottir2002], offers a parsimonious framework for understanding antisocial tendencies by representing the shared variance among dark traits [@HilbigZettlerMoshagenThielmann2021; @Zettler2021].

Research consistently links dark traits and D to reduced cooperation and honesty [@Zhao2015; @Thielmann2019], particularly in one-shot economic games like the dictator game [@Hilbig2021]. However, these single-interaction studies cannot capture the dynamics crucial to real-world exchanges, such as reputation formation [@Bohnet2004] and strategic adaptation over time. Understanding how D influences behavior in repeated exchanges is critical, especially given that the strategic manipulation inherent in D (e.g., its Machiavellian component; @Jones2009) may only fully manifest across multiple interactions. Yet, the specific impact of D in repeated trust games remains largely unexplored. Prior work using repeated games often involved different paradigms (e.g., sequential partners; @Gong2019) or focused on clinical samples and related constructs [@Rosenberger2019], leaving a gap in understanding how D operates strategically in sustained interactions within the general population.

The present study aims to fill this gap by examining how D-factor influences strategic trustworthiness across 25 rounds of a repeated trust game. A key challenge in studying dynamic social interactions is controlling the behavior of the interaction partner. To address this, we employ an innovative methodology using Hidden Markov Model (HMM) agents as investors. HMMs [@Rabiner1989] are computational models ideal for capturing behavioral sequences driven by underlying states. Critically, our HMMs were not abstract models but were trained on large datasets of human behavior in prior trust games. This data-driven approach allows us to create standardized investors that exhibit realistic, human-like response patterns while enabling precise experimental manipulation of their interaction strategy – a blend of ecological validity and experimental control difficult to achieve otherwise [@MacyWiller2002].

We leverage this methodology to directly test strategic adaptation related to D by manipulating opponent 'exploitability'. We developed two distinct HMM investor types based on typical human behavior patterns: a 'human-like' agent exhibiting a 'sticky' mid-trust state (requiring large return deviations to shift state), making it potentially vulnerable to gradual exploitation; and a 'responsive' agent specifically modified to eliminate this mid-state inertia, forcing rapid transitions based on the trustee’s immediate returns. This controlled comparison between a passively exploitable versus a more reactive partner provides a novel way to assess if high-D individuals strategically adjust their behavior based on the opponent's interaction dynamics.

Therefore, this study offers several unique contributions: First, it provides the first examination of the unified D-factor within the dynamic context of a multi-round (25-round) repeated trust game. Second, it introduces and utilizes an innovative HMM-based methodology to experimentally manipulate opponent responsiveness/exploitability in a realistic manner. Finally, it investigates not only the enactment of exploitative strategies associated with D but also the potential limits of these strategies when facing adaptive partners. Understanding these dynamics has significant implications for bridging personality psychology and behavioral economics.

Based on the theoretical conceptualization of D and the dynamics of repeated games with varying opponent responsiveness, we hypothesize that individuals scoring higher on the D-factor will exhibit less trustworthy behavior as trustees, particularly in later rounds of the game. Additionally, we expect High-D individuals to show greater strategic adaptation to opponent type, with more pronounced exploitation of predictable opponents compared to responsive ones. Finally, we explore whether these behavioral patterns are accompanied by systematic differences in perception of opponents, with High-D individuals potentially showing more negative evaluations regardless of opponent behavior.


# Methods 



```{r load-packages05}
library(papaja)
library(kableExtra)
require(knitr)

# using some functions dplyr, ggpubr, PairedData and sjPlot. Need to be loaded. 
library(tidyverse)
library(afex)
library(PairedData)
library(multcompView)
library(lsmeans)
library(depmixS4)
library(flextable)
library(grid)
library(gridExtra)
library(forcats)
library(ggsignif)
library(magick)
library(cowplot)
library(ggplot2)
library(scales)  # for alpha()

```



```{r, include=FALSE}
Anti_social <-  c(0.1025436430408, 0.1221931236853, 0.1345215238995,
0.1368182252617, 0.1285592471751, 0.1116014322677, 0.0895041220882,
0.0663166721334, 0.0453950277118, 0.0287077419587, 0.0167723588011,
0.0090530028158, 0.0045143317507, 0.0020796744990, 0.0008851094702,
0.0003480141146, 0.0001264134789, 0.0000424213859, 0.0000131513231,
0.0000037665630, 0.0000009965755)

Neutral <- c(0.003393529, 0.006930874, 0.013053553, 0.022671228,
0.036310144, 0.053627606, 0.073039389, 0.091734929, 0.106248217,
0.113479701, 0.111769796, 0.101517390, 0.085028780, 0.065675083,
0.046778251, 0.030725245, 0.018610323, 0.010394861, 0.005354126,
0.002543094, 0.001113881)

Pro_social <- c(0.003162697, 0.001057162, 0.001410197, 0.001881016,
0.002508877, 0.003346113, 0.004462480, 0.005950950, 0.007935434,
0.010581067, 0.014107909, 0.018809194, 0.025075644, 0.033427845,
0.044559370, 0.059394206, 0.079163228, 0.105506029, 0.140606514,
0.187373417, 0.249680651)

investment <- seq(0:20) -1

response_probs <- as.data.frame(cbind(investment,Anti_social,Neutral,Pro_social)) %>% 
  rename("low-trust" = "Anti_social", "medium-trust"="Neutral", "high-trust" = "Pro_social") %>%
  pivot_longer(cols=c("low-trust","medium-trust","high-trust"),
                    names_to='Investor_state',
                    values_to='probability') %>% 
   mutate(across(Investor_state, factor, levels=c("low-trust","medium-trust","high-trust")))
```

```{r}

plotinvHMM <- ggplot(response_probs,                            
       aes(x = investment,
           y = probability,
           fill = Investor_state)) +
  geom_bar(stat = "identity",
           position = "dodge") + 
  labs(fill='Latent investor state', x = "Investment", y= "Probability") + 
  theme_bw() + 
  theme(legend.position = "bottom",  legend.text = element_text(size = 10),  legend.title = element_text(size = 10))
  
plotinvHMM
```


```{r}
# Parameters for HMM human-like Transition Function
unhappy_pars <- rbind(c(0,0), c(-3.366027, 0.40910797 ), c(-3.572619,0.08137274)) 
neutral_pars <- rbind(c(0,0), c(3.3142637, 0.3763408), c(0.9169736, 0.4502838))
happy_pars   <- rbind(c(0,0), c(0.7134085, 0.02101626), c(2.2215478 ,0.16162964))

pars_inv <- list(unhappy_pars, neutral_pars, happy_pars)

```



```{r}
plot_HMM_transitions <- function(ns, pars_mat) {

  trans_prob <- data.frame(
    from = rep(1:ns, each=100*ns),
    to = rep(1:ns, each=100),
    ret = seq(-20,60,length=100),
    probs = 0
  )
  
  
  y <- matrix(0.0,ncol=ns, nrow=100)
  
  for(from in 1:ns) {
  pars <- matrix(pars_mat[[from]], ncol=2)
  # print(pars)
  
    for(to in 1:ns) {
        x <- trans_prob[trans_prob$from == from & trans_prob$to == to,"ret"]
        y[,to] <- exp(pars[to,1] + pars[to,2]*x)
    }
    y <- y/rowSums(y)

    
    for(to in 1:ns) {
      trans_prob$probs[trans_prob$from == from & trans_prob$to == to] <- y[,to]
    }
  }
  
  df <- as.data.frame(trans_prob) %>% 
    mutate(from = recode(from, "1" = "low-trust", "2" = "medium-trust", "3" = "high-trust"),
           to = recode(to, "1" = "low-trust", "2" = "medium-trust", "3" = "high-trust") ) %>% 
    mutate(across(from, factor, levels=c("low-trust","medium-trust","high-trust"))) %>% 
    mutate(across(to, factor, levels=c("low-trust","medium-trust","high-trust")))
                                    
  
    # Create a separate data frame with the background colors
  bg_colors <- data.frame(
    from = factor(c("low-trust", "medium-trust", "high-trust"), levels=c("low-trust","medium-trust","high-trust"))
  )
  
  # plotting code...
  ggplot() +
    geom_rect(data = bg_colors, aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, fill = from), alpha = 0.1) +
    geom_line(data = df, aes(x = ret, y = probs, colour = as.factor(to))) +
    facet_wrap(~from, labeller = labeller(from = function(x) paste("From", x, "state on trial t"))) +
    ylim(c(0,1)) +
    scale_fill_manual(values = c("low-trust" = "red", "medium-trust" = "green", "high-trust" = "blue"),
                    name = "From state") +  # Changed legend title for 'fill' here
    scale_color_manual(values = c("low-trust" = "red", "medium-trust" = "green", "high-trust" = "blue"),
                       labels = c("low-trust", "medium-trust", "high-trust"),
                       name = "State transitioned to") +
    labs(x = "Investor's net return on trial t", y = "Transition probability to \nState on trial t+1", color = 'State transitioned to') +
    theme_bw() +
    theme(legend.position = "bottom",
          legend.text = element_text(size = 10),
          legend.key.size = unit(1, 'lines'),
          legend.spacing.x = unit(0.1, 'in'),
          legend.title = element_text(size = 10),
          legend.margin = margin(t = 0.2, b = 0, unit = 'cm'),
          plot.margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "cm"),
          strip.text = element_text(size = 7),
          legend.box = "vertical" # Arrange legends vertically
    ) +
    guides(fill = guide_legend(order = 1, title.position = "left", title.hjust = 0.3),
           color = guide_legend(order = 2, title.position = "left", title.hjust = 0.3))
}

```


```{r}

# Parameters for HMM human-like Transition Function
unhappy_pars <- rbind(c(0,0), c(-3.366027, 0.40910797 ), c(-3.572619,0.08137274)) 
neutral_pars <- rbind(c(0,0), c(3.3142637, 0.3763408), c(0.9169736, 0.4502838))
happy_pars   <- rbind(c(0,0), c(0.7134085, 0.02101626), c(2.2215478 ,0.16162964))

pars_inv <- list(unhappy_pars, neutral_pars, happy_pars)
plotInvTran <- plot_HMM_transitions(3, pars_inv) 

plotInvTran 



unhappy_pars_vol <- rbind(c(0,0), c(-3.366027, 0.40910797 ), c(-3.572619,0.08137274)) 
neutral_pars_vol <- rbind(c(0,0), c(1.0,0.27), c(-4, 0.75))
happy_pars_vol   <- rbind(c(0,0), c(0.7134085, 0.02101626), c(2.2215478 ,0.16162964))

pars_inv_vol <- list(unhappy_pars_vol, neutral_pars_vol, happy_pars_vol)
plotInvVol <- plot_HMM_transitions(3, pars_inv_vol) 



```

## Participants


<!-- Load preprocessed data -->
```{r}
final_data <- read_csv("data/anonymized_final_data.csv")

num_participants <- length(unique(final_data$playerId))
cat("Number of participants: ", num_participants)

# Count D factor groups
d_factor_counts <- final_data %>%
  dplyr::select(playerId, d_level) %>%
  distinct() %>%
  count(d_level) %>%
  print()

# Count order of play (responsive first vs HMM first)
order_counts <- final_data %>%
  dplyr::select(playerId, volatile_first) %>%
  distinct() %>%
  count(volatile_first) %>%
  print()
```



```{r modAllReturns}

final_data <- final_data %>% mutate(ret_pct_na = ifelse(investment==0,NA,return/(3*investment)),
                                    roundPayoff = 3*investment - return,
                                    opponent.f = factor(gameOpponent, levels = c("AI_HMM", "AI_HMM_vol")),
                                    investorState.f = factor(investorState, levels = c("unhappy","neutral","happy")),
                                    d_level = as.factor(d_level),
                                    roundNum = as.numeric(as.character(roundNum)),
                                    inv_scaled = as.vector(scale(investment)),
                                    # Centering the subscales scores for regression analysis
                                    cal_scaled = as.vector(scale(callous_score,scale=FALSE)),
                                    sad_scaled = as.vector(scale(sadism_score,scale=FALSE)),
                                    vin_scaled = as.vector(scale(vindict_score,scale=FALSE)),
                                    dec_scaled = as.vector(scale(deceit_score,scale=FALSE))) %>% 
                             dplyr::select(-c("gameOpponent","investorState"))

# index players
final_data <- final_data %>%
  group_by(playerId) %>%
  mutate(player_index = cur_group_id()) %>%
  ungroup() %>%
  arrange(player_index)


# anonym_data <- final_data %>%  dplyr::select(playerId, gameNum.f,volatile_first, roundNum, investment, return)
# write.csv(anonym_data, "anonym_RTG_data.csv")
```

```{r}
# Load the pre-processed and anonymized demographic data.
# This file was generated by 'create_anonymized_data.R' in the private repo
# and only contains data for the participants in the study.
demographic_subset <- read_csv("data/anonymized_demographics.csv")


# # Extract demographic information for participants in final_data
# matching_participants <- demographics[demographics$Participant.id %in% final_data$id, ]
# 
# # Select only the relevant columns we need
# demographic_subset <- matching_participants[, c("Participant.id", "Age", "Sex", "Country.of.birth", "Ethnicity.simplified")]

# Calculate gender proportions
gender_counts <- table(demographic_subset$Sex)
gender_proportions <- prop.table(gender_counts) * 100

# Calculate mean age
mean_age <- mean(as.numeric(demographic_subset$Age), na.rm = TRUE)
sd_age <- sd(as.numeric(demographic_subset$Age), na.rm = TRUE)

# Print results
print("Gender Distribution:")
print(gender_counts)
print(paste0("Proportion of Male participants: ", round(gender_proportions["Male"], 1), "%"))
print(paste0("Proportion of Female participants: ", round(gender_proportions["Female"], 1), "%"))
print(paste0("Mean age: ", round(mean_age, 1), " years"))
print(paste0("SD age: ", round(sd_age, 1), " years"))

# Optional: Create a bar plot for gender distribution
barplot(gender_counts, main="Gender Distribution", 
        col=c("lightblue", "pink"), 
        ylab="Number of Participants")
```





To obtain groups with distinct D-factor levels, 1,243 participants were pre-screened via Prolific Academic (prolific.co) using the 16-item Dark Factor of Personality Questionnaire (D16). Two groups were selected for the main experiment: High-D (90th percentile or higher, D score \> 42, N=91) and Low-D (10th percentile or lower, score \<  22, N=92), totaling 183 participants (44% female). These were then invited through Prolific to take part in the main experiment.

A sample size of 180 participants was determined *a priori* through conducting a power analysis using Monte Carlo simulations with the *simr* package in R. The analysis specifically targeted the three-way interaction between d-score, opponent type (Human-like vs. Responsive), and investment level. Parameters for the simulation were based on previous studies, with an expected effect size of $-0.1$ (correlation between d-score and returns, see @Thielmann2020personality), alpha level of $0.05$, and desired power of $0.90$. Starting with 50 participants, we iteratively generated synthetic data for a task with $25$ rounds per condition and fitted linear mixed-effects models with random intercepts for participants. The simulations incorporated realistic parameter estimates and fixed effects derived from previous research using the same paradigm. This analysis indicated that a sample of 180 participants would provide at least $90\%$ power to detect the hypothesized three-way interaction.


## Design and Materials

The experiment employed a 2 (HMM Type: Human-like vs. Responsive) × 2 (D-Factor: High vs. Low) mixed design, with HMM Type as a within-subjects factor. Participants completed two phases, each involving a 25-round Repeated Trust Game (RTG), against either the Human-like or Responsive HMM investor, with the order counterbalanced. 
The experimental interface was designed and implemented online using Empirica v1 [@Almaatouq2021], with an estimated completion time of 30 minutes per participant. The study received approval from the University of [Redacted] Medical Faculty ethics commission (ID:S-708/2023) and the experiment was performed in accordance with the ethics board guidelines and regulations. All participants provided informed consent prior to their participation. 

### Repeated Trust Game (RTG)
Based on @Berg1995, participants always acted as the trustee. In each round, the HMM investor received 20 units and decided how much (0-20) to invest. This investment was tripled, and the trustee decided how much of the tripled amount to return to the investor. Trustees knew that returning more than one-third resulted in a gain for the investor. Participants chose a representative icon; the opponent's icon changed between phases to simulate a new partner. To enhance realism, participants were not told opponents were computerised; simulated pairing delays and variable response latencies (5-10s) were included.


```{r}
# Identify ethnic distribution and country of birth from demographics data

# Calculate ethnicity distribution
ethnicity_counts <- table(demographic_subset$`Ethnicity simplified`)
ethnicity_percentages <- prop.table(ethnicity_counts) * 100

# Print ethnicity results
print("Ethnicity Distribution:")
print(ethnicity_counts)
print(paste0("Proportion of White participants: ", round(ethnicity_percentages["White"], 1), "%"))

# Assuming there's a column named "Country.of.birth" or similar in your data
# If the column has a different name, replace it accordingly
country_counts <- table(demographic_subset$`Country of birth`)
country_percentages <- prop.table(country_counts) * 100

# Sort countries by frequency in descending order
sorted_countries <- sort(country_counts, decreasing = TRUE)
sorted_percentages <- prop.table(sorted_countries) * 100

# Get number of unique countries
unique_countries <- length(country_counts)

# Print country of birth results
print(paste0("Number of unique countries of birth: ", unique_countries))
print("Top countries of birth:")
for (i in 1:min(5, length(sorted_countries))) {
  country_name <- names(sorted_countries)[i]
  country_percent <- sorted_percentages[country_name]
  print(paste0(country_name, ": ", round(country_percent, 1), "%"))
}

```
```{r}
# Load libraries (if not already loaded)
library(dplyr)
library(tidyr) # For pivot_wider and unnest

# --- Ensure the merged data frame exists ---
# (Assuming 'final_data' and 'demographic_subset' are loaded and processed)

# Get unique participant IDs and their d_level from final_data
participant_d_levels <- final_data %>%
  distinct(playerId, d_level) # Ensure this pulls rows with "low_D" and "high_D"

# Merge with demographic subset and perform conversions
demographics_with_dlevel <- participant_d_levels %>%
  inner_join(demographic_subset, by = c("playerId")) %>%
  mutate(
    # *** ADD THIS LINE TO CONVERT Age TO NUMERIC ***
    Age = as.numeric(as.character(Age)), # Convert Age to numeric type

    # Correct d_level factor conversion
    d_level = factor(d_level, levels = c("low_D", "high_D")),

    # Convert other categorical variables to factors
    Sex = factor(Sex),
    Ethnicity.simplified = factor(`Ethnicity simplified`)
  ) %>%
  # IMPORTANT: Filter out any rows where d_level became NA
  filter(!is.na(d_level)) %>%
  # *** ADD RECODING HERE ***
  # Rename the specific level "CONSENT_REVOKED" for Sex and Ethnicity
  mutate(
    Sex = recode(Sex, "CONSENT_REVOKED" = "Prefer not to say"),
    Ethnicity.simplified = recode(Ethnicity.simplified, "CONSENT_REVOKED" = "Prefer not to say")
  )

# --- Helper function for formatting p-values ---
format_p <- function(p_value) {
  if (is.na(p_value)) return(NA_character_)
  if (p_value < 0.001) return("<0.001")
  p_formatted <- format(round(p_value, 3), nsmall = 3)
  return(p_formatted)
}

# --- 1. Calculate Group Sizes ---
# Ensure all levels are counted, even if 0
group_sizes <- demographics_with_dlevel %>%
  count(d_level, .drop = FALSE) %>%
  pivot_wider(names_from = d_level, values_from = n, values_fill = 0)

# *** CORRECTION HERE: Use backticks for names with underscores ***
n_low <- group_sizes$`low_D`[1]
n_high <- group_sizes$`high_D`[1]

# Check if groups exist after potential filtering
if(is.null(n_low) || is.na(n_low)) n_low <- 0
if(is.null(n_high) || is.na(n_high)) n_high <- 0

# --- 2. Age Summary & Test ---
age_summary <- demographics_with_dlevel %>%
  group_by(d_level) %>%
  summarise(
    mean_age = mean(Age, na.rm = TRUE),
    sd_age = sd(Age, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(summary_str = sprintf("%.1f (%.1f)", mean_age, sd_age)) %>%
  dplyr::select(d_level, summary_str) %>%
  pivot_wider(names_from = d_level, values_from = summary_str)

# Perform test (use tryCatch for robustness)
age_p_value <- NA_character_
# Only run test if both groups have >1 participant after corrections
if (n_low > 1 && n_high > 1) {
  tryCatch({
      age_test <- t.test(Age ~ d_level, data = demographics_with_dlevel)
      age_p_value <- format_p(age_test$p.value)
  }, error = function(e) { cat("Age test failed:", conditionMessage(e), "\n") })
}

# *** CORRECTION HERE: Referencing pivoted columns with backticks ***
age_row <- data.frame(
  Characteristic = "Age, years, Mean (SD)",
  Low = ifelse(n_low > 0 && "low_D" %in% names(age_summary), age_summary$`low_D`, "N/A"),
  High = ifelse(n_high > 0 && "high_D" %in% names(age_summary), age_summary$`high_D`, "N/A"),
  P_value = age_p_value
)

```

```{r}
# --- Updated Categorical Variable Summary & Test Function ---
summarize_categorical <- function(data, variable_name, characteristic_label, prefer_not_say_value = "CONSENT_REVOKED", display_name = "Prefer not to say") {
  var_sym <- sym(variable_name)

  # --- Calculate N and Percent per group ---
  summary_stats <- data %>%
    # Ensure the variable is treated as a factor; handle potential NAs explicitly if needed
    mutate({{ var_sym }} := factor({{ var_sym }}, exclude = NULL)) %>% # `exclude = NULL` keeps NA as a level if present
    # Count occurrences including the "Prefer not to say" value
    count(d_level, {{ var_sym }}, .drop = FALSE) %>%
    # Identify rows that are NOT the specified "Prefer not to say" value
    mutate(is_valid_category = !(!is.na({{ var_sym }}) & {{ var_sym }} == prefer_not_say_value)) %>% # Check for NA too
    group_by(d_level) %>%
    # Calculate total N ONLY for valid categories for percentage calculation
    mutate(
        valid_total_n = sum(n[is_valid_category], na.rm = TRUE),
        # Calculate percentage based on valid total. Result is NA if valid_total_n is 0.
        # Percentage is 0 if count 'n' is 0.
        prop = ifelse(is_valid_category & valid_total_n > 0, n / valid_total_n, NA_real_)
      ) %>%
    ungroup() %>%
    # Format: show n for all. Show % for valid categories relative to valid total.
    mutate(
        summary_str = case_when(
            # For valid categories: "n (prop%)"
            is_valid_category & !is.na(prop) ~ sprintf("%d (%.1f%%)", n, prop * 100),
            # For "Prefer not to say" or NA level: just "n"
            !is_valid_category | is.na({{ var_sym }}) ~ sprintf("%d", n),
             # Fallback if prop was NA for a valid category (means valid_total_n was 0)
            is_valid_category & is.na(prop) ~ sprintf("%d (NA%%)", n),
            TRUE ~ "" # Should not happen
        )
      ) %>%
    # Rename the level for display *before* pivoting
    mutate(
      {{ var_sym }} := recode(factor({{ var_sym }}), !!prefer_not_say_value := display_name)
      ) %>%
    dplyr::select(d_level, {{ var_sym }}, summary_str) %>%
    # Pivot wider. Use a fill that makes sense for potentially mixed formats
    pivot_wider(names_from = d_level, values_from = summary_str, values_fill = "0")

  # --- Perform Test (excluding "Prefer not to say" and NA) ---
  p_value_str <- NA_character_
  # Filter data for the test
  data_for_test <- data %>%
    filter(!is.na({{ var_sym }}) & !({{ var_sym }} %in% prefer_not_say_value))

  # Only run test if both groups still have data after filtering
  n_low_test <- sum(data_for_test$d_level == "low_D")
  n_high_test <- sum(data_for_test$d_level == "high_D")

  if (n_low_test > 0 && n_high_test > 0) {
      tryCatch({
          # Ensure table has valid dimensions after filtering
          if(n_distinct(data_for_test[[variable_name]]) > 0 && n_distinct(data_for_test$d_level) > 1) {
              cont_table <- table(data_for_test$d_level, data_for_test[[variable_name]])
              if(all(dim(cont_table) > 1)) { # Check if table has >1 row and >1 col
                  expected_counts <- suppressWarnings(chisq.test(cont_table)$expected)
                  min_expected <- min(expected_counts)

                  if (min_expected < 5 && nrow(cont_table) == 2 && ncol(cont_table) == 2) {
                      test_result <- fisher.test(cont_table)
                  } else {
                      # Use simulate.p.value only if needed and possible
                      simulate <- min_expected < 5
                      test_result <- suppressWarnings(chisq.test(cont_table, simulate.p.value = simulate))
                  }
                  p_value_str <- format_p(test_result$p.value)
              } else {
                 cat(variable_name, "test skipped: Contingency table not valid (dim<=1) after excluding '", prefer_not_say_value, "'.\n", sep="")
              }
          } else {
             cat(variable_name, "test skipped: Not enough distinct values/groups after excluding '", prefer_not_say_value, "'.\n", sep="")
          }
      }, error = function(e) { cat(variable_name, "test failed:", conditionMessage(e), "\n") })
  } else {
     cat(variable_name, "test skipped: One or both groups empty after excluding '", prefer_not_say_value, "'.\n", sep="")
  }

  # --- Prepare rows for the final table ---
  # Adjust header to mention what percentages refer to? Optional.
  header_row <- data.frame(
    Characteristic = sprintf("%s, n (%% Valid)", characteristic_label), # Note % is of valid
    Low = "",
    High = "",
    P_value = p_value_str # P-value from test excluding prefer not to say
  )

  level_rows <- summary_stats %>%
    mutate(Characteristic = paste0("  ", !!var_sym)) %>%
    # Select columns, ensuring the factor levels (like 'Prefer not to say') are included
    dplyr::select(Characteristic, any_of(c("low_D", "high_D"))) %>%
    rename(Low = `low_D`, High = `high_D`) %>%
    mutate(P_value = "")

  # Order rows: put "Prefer not to say" last? Optional.
  level_order <- c(levels(level_rows$Characteristic)[levels(level_rows$Characteristic) != paste0("  ", display_name)], paste0("  ", display_name))
  level_rows <- level_rows %>% arrange(factor(Characteristic, levels = level_order))

  return(bind_rows(header_row, level_rows))
}

# --- Apply to Sex and Ethnicity ---
# Call the updated function, specifying the value and desired display name
sex_rows <- summarize_categorical(demographics_with_dlevel, "Sex", "Gender",
                                   prefer_not_say_value = "CONSENT_REVOKED", display_name = "Prefer not to say")
ethnicity_rows <- summarize_categorical(demographics_with_dlevel, "Ethnicity.simplified", "Ethnicity",
                                         prefer_not_say_value = "CONSENT_REVOKED", display_name = "Prefer not to say")

# --- Assemble Final Table (No changes needed here) ---
final_table <- bind_rows(
  age_row,
  sex_rows,
  ethnicity_rows
)

# --- Adjust Final Column Names (No changes needed here) ---
colnames(final_table) <- c(
  "Characteristic",
  sprintf("Low D (N=%d)", n_low),
  sprintf("High D (N=%d)", n_high),
  "P-value"
)

# --- Display Table ---
print(final_table, row.names = FALSE)

# Optional: Use knitr::kable for better formatting
# if (requireNamespace("knitr", quietly = TRUE)) {
#   print(knitr::kable(final_table, format = "pipe"))
# }

cat("\nNotes:\n")
cat("- Age presented as Mean (SD); compared using t-test (check assumptions).\n")
cat("- Categorical variables presented as n (% Valid).\n")
cat("- Percentages for categorical variables are calculated excluding 'Prefer not to say' responses.\n") # Added note
cat("- Statistical tests for categorical variables exclude 'Prefer not to say' responses.\n") # Added note
cat("- P-values < 0.001 are shown as '<0.001'.\n")
```





The mean age of participants was $33.1$ years, with an $9.7$-year standard deviation. The majority of participants identified ethnically as White ($57$\%). The online cohort registered $38$ unique countries of birth with the most frequent being South Africa ($24$\%), the U.K. ($20$\%) followed by Poland ($5$\%) and Greece ($4$\%). Participants were paid a fixed fee of £4 plus a bonus payment dependent on their performance that averaged £$0.5$. We collected data over multiple sessions between October and November 2024.




```{r combinedPlots,include=F}
# Ensure necessary packages are loaded
library(ggplot2)
library(patchwork)
library(magick)
library(grid) # Needed for rasterGrob

# ---Code to Generate Plots (cleaned) ---

# Parameters for HMM human-like Transition Function
unhappy_pars <- rbind(c(0,0), c(-3.366027, 0.40910797 ), c(-3.572619,0.08137274))
neutral_pars <- rbind(c(0,0), c(3.3142637, 0.3763408), c(0.9169736, 0.4502838))
happy_pars   <- rbind(c(0,0), c(0.7134085, 0.02101626), c(2.2215478 ,0.16162964))

pars_inv <- list(unhappy_pars, neutral_pars, happy_pars)
# Assuming plot_HMM_transitions returns a ggplot object
plotInvTran <- plot_HMM_transitions(3, pars_inv)

# Parameters for Responsive HMM
unhappy_pars_vol <- rbind(c(0,0), c(-3.366027, 0.40910797 ), c(-3.572619,0.08137274))
neutral_pars_vol <- rbind(c(0,0), c(1.0,0.27), c(-4, 0.75))
happy_pars_vol   <- rbind(c(0,0), c(0.7134085, 0.02101626), c(2.2215478 ,0.16162964))

pars_inv_vol <- list(unhappy_pars_vol, neutral_pars_vol, happy_pars_vol)
# Assuming plot_HMM_transitions returns a ggplot object
plotInvVol <- plot_HMM_transitions(3, pars_inv_vol)

# Assuming 'response_probs' dataframe exists in your environment
plotinvHMM <- ggplot(response_probs,
                    aes(x = investment,
                        y = probability,
                        fill = Investor_state)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  labs(fill='Latent investor state', x = "Investment", y= "Probability") +
  theme_bw() +
  theme(legend.position = "bottom", legend.text = element_text(size = 10), legend.title = element_text(size = 10))

# --- Code to Read and Prepare the Image ---

# Define the path to your image file (make sure this path is correct relative to your .Rmd file)
image_path <- "plots/experimentDesign.png"

# Read the image using magick
img <- image_read(image_path)

# Convert the magick image to a raster grob (graphical object)
img_grob <- grid::rasterGrob(img, interpolate=FALSE)

# Wrap the grob so patchwork can use it
img_panel <- wrap_elements(img_grob)

# --- Combine Plots and Image using Patchwork ---

# Arrange in a 2x2 grid:
# ( Plot A + Plot B ) /
# ( Plot C + Image D )
combined_figure <- (img_panel + plotinvHMM) / (plotInvTran + plotInvVol)


# --- Apply Layout Controls and Annotation ---
final_plot <- combined_figure + plot_annotation(tag_levels = 'A') 

# Save the plot with a simple name that avoids underscores
ggsave("plots/figure1.pdf", final_plot, width = 12, height = 7, dpi = 300)
  
```



\begin{landscape}
\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{plots/figure1.pdf}
\caption{\small{Panel A: A timeline of the experiment. The RTG is played in dyads, with participants always assigned the role of the trustee and the HMM agent that of the investor. The investor is endowed with 20 units at the start of each round. They need to decide how much of that endowment they want to invest with the trustee. The investment is then multiplied by a factor of 3 and sent to the trustee who needs to decide how much of the multiplied investment they want to send back to the investor. The difference between phases is the type of agents participants are facing. Panels B - C: We construct the artificial investor agent by fitting a three-state HMM to data of human investors engaged in the 10 round RTG. From the fitted HMM, we get the distribution of investments by the human-like agent, conditional on its latent state as shown in Panel B. The fitted HMM also yields the transition probability of the agent to a state on trial t+1 as a function of the net return (difference between the investment sent and the amount received in return) on trial t as shown in Panel C. Each plot in Panel C represents a different starting latent state on trial t, and each line represents the probability of transitioning to a particular state in trial t+1.  The responsive HMM agent (Panel D) is much more likely to transition out of the mid-trust state. Transitions in the medium and high trust states were identical for both agents.}}
\label{fig:combinedPlots}
\end{figure}
\end{landscape}


### HMM Investor Construction
Computerised investors were implemented as Hidden Markov Models (HMMs) trained on an independent dataset of 388 10-round RTGs (see Supplement for details). This data-driven approach aimed to create investors mimicking human interaction patterns. The inferred HMM used three latent states ("low-trust", "medium-trust", "high-trust"), each associated with a learned probability distribution over possible investments (0-20 units; Figure \@ref(fig:combinedPlots).B). Transitions between states were probabilistic, modeled as a function of the investor's net return (amount returned - amount invested) in the previous round (Figure \@ref(fig:combinedPlots).C). For instance, higher net returns increased the probability of transitioning to higher trust states. The HMM started each 25-round game in the "medium-trust" state. Investor actions involved sampling an investment from the current state's distribution; the state for the next round was determined by sampling from the transition probabilities based on the previous round's net return. (See Supplement for full HMM specification).


### HMM Investor Types 

Two HMM types were used:

* Human-like HMM: Directly resulted from fitting the human dataset. It exhibited a tendency to remain in the "medium-trust" state unless net returns were substantially high or low (Figure \@ref(fig:combinedPlots).C).
* Responsive HMM: Created by adjusting the Human-like HMM's parameters to eliminate the 'stickiness' of the mid-trust state. Specifically, the probability of *remaining* in the medium-trust state was set near zero for non-nil net returns (Figure \@ref(fig:combinedPlots).D). This modification made the agent highly sensitive to trustee behavior, rapidly shifting to low- or high-trust states in response to exploitation or generosity, respectively. Other state parameters remained unchanged.

### Other Measures:
After each RTG phase, participants rated the perceived cooperativeness, trustworthiness, and their willingness to play again with the investor (1-10 scales). Post-experiment measures included the Turing test (perceived humanness of opponents) and open-ended questions about strategy.


## Procedure

Participants began by providing informed consent. They were then instructed that the study comprised two distinct phases, each involving interaction with a different player. The stated objective for participants was to accumulate the maximum number of points throughout all phases. Information regarding the specific number of rounds within each phase was not disclosed to them initially. During the concluding round (round 25) of both phases, participants received a visual cue in the form of a flashing message, indicating that it was the final round of that particular game.

The initial phase involved participating in a 25-round Repeated Trust Game (RTG). In this game, participants consistently played the role of the trustee, interacting with the same designated investor across all 25 rounds. The second phase replicated the setup of the first phase exactly, involving another 25-round RTG with the participant again acting as the trustee. The key difference in this phase was the introduction of a new opponent.

Upon the completion of the RTG in each separate phase, participants were prompted to provide the investor ratings. They rated the perceived cooperativeness and trustworthiness of the co-player they had just interacted with, and also indicated their willingness to engage in future games with that same player. These ratings were captured on a scale ranging from 1 to 10, where 10 signified the most positive assessment.

After finishing both game phases, participants were asked for their perception regarding the nature of the other players – specifically, whether they believed them to be human or computer agents (Turing test). They were also requested to articulate the strategy they employed during each of the two games. The process concluded with a debriefing session, during which participants were thanked for their involvement in the study.


## Statistical Analysis

To analyse participants' behavior in the RTG, we employed several complementary statistical approaches. Our primary analysis used linear mixed effects modelling to examine how percentage returns (proportion of tripled investment returned to investor) varied as a function of experimental factors. The model included Opponent type (Human-like vs. Responsive HMM), opponent presentation order (Order: Responsive First vs. Human-like First), Investment amount, round number, and D-factor group (High vs. Low) as fixed effects, along with all their interactions. Random effects included participant-wise intercepts and slopes for Investment. This approach allowed us to account for the nested structure of the data while examining how D-factor influenced behavior across conditions.

The model was estimated using the `afex` package [@Singmann2022] in R with Kenward-Roger approximation for degrees of freedom. We Z-transformed the Investment variable to facilitate interpretation of main effects in the presence of interactions. For significant interactions, we conducted planned contrasts using the `emmeans` package with Sidak corrections to control familywise error rates. Model complexity was constrained by reliable estimation considerations, resulting in an optimal random effects structure [@Matuschek2017]. Similar approaches were used for analysing HMM agent investments and participant ratings of co-players.

Participants' perceptions (ratings of cooperativeness, trustworthiness, willingness to play again) were analysed with LME models including D-factor level, HMM type, game order, and interactions as fixed effects, with participant-wise random intercepts.

To examine temporal dynamics within the game, the main interaction period (rounds 1-24) was divided into three equal, consecutive periods: early (rounds 1-8), middle (rounds 9-16), and late (rounds 17-24), representing the beginning, middle, and end of the game, respectively. Analyses compared key variables between groups across these periods. For the final round of each game, where no future interactions were anticipated (resembling a one-shot dictator game), we compared absolute returns and percentage returns between High-D and Low-D groups using both Welch's t-tests and non-parametric Wilcoxon rank-sum tests. The latter was included given the smaller sample size for this single-round comparison and to ensure robustness of our findings regardless of distributional assumptions. Finally, we analysed total payoffs earned by participants to determine whether behavioral differences resulted in differing economic outcomes. For debrief questions, we calculated the percentage of participants who believed they played against human opponents or were uncertain about their opponent's nature, providing insight into the ecological validity of our HMM agents. Full model specifications and additional analytical details are provided in the supplement.

## Data, Materials, and Code Availability
The data and analysis code that support the findings of this study are available at a public GitHub repository. The repository contains all materials needed to reproduce the analyses, including anonymized data, code (in R), and a README file. To maintain anonymity during the peer-review process, the link will be provided upon acceptance or can be shared upon request to the editorial office.


# Results


<!-- ### Distribution of D factor and its subscales scores:  -->

```{r}
library(stringr)
create_distribution_plot <- function(data, column_name) {
  # Convert column name to symbol for evaluation
  col_sym <- sym(column_name)
  
  # Calculate statistics
  mean_val <- mean(pull(data, !!col_sym), na.rm = TRUE)
  sd_val <- sd(pull(data, !!col_sym), na.rm = TRUE)
  n_val <- nrow(data)
  
  # Get column range for x-axis breaks
  col_min <- floor(min(pull(data, !!col_sym), na.rm = TRUE))
  col_max <- ceiling(max(pull(data, !!col_sym), na.rm = TRUE))
  break_seq <- seq(col_min, col_max, by = 2)
  
  # Create the plot
  p <- ggplot(data, aes(x = !!col_sym)) +
    # Add histogram
    geom_histogram(aes(y = after_stat(density)), 
                  binwidth = 2, 
                  fill = "lightblue", 
                  color = "black", 
                  alpha = 0.7) +
    # Add density curve
    geom_density(color = "darkred", size = 1) +
    # Add mean line
    geom_vline(aes(xintercept = mean_val), 
               color = "darkred", 
               linetype = "dashed", 
               size = 1) +
    # Customize theme and labels
    theme_minimal() +
    labs(
      title = paste("Distribution of", gsub("_", " ", column_name)),
      subtitle = sprintf("Mean = %.2f, SD = %.2f, N = %d", 
                        mean_val, sd_val, n_val),
      x = gsub("_", " ", str_to_title(column_name)),
      y = "Density"
    ) +
    # Basic theme customization
    theme(
      plot.title = element_text(face = "bold", size = 14),
      plot.subtitle = element_text(size = 11),
      panel.grid.minor = element_blank()
    ) +
    # Set x-axis breaks
    scale_x_continuous(breaks = break_seq)
  
  return(p)
}

```

```{r}
# For your original example
plot_total <- create_distribution_plot(final_data, "total_score")
print(plot_total)
```


```{r}
# For your original example
plot_vin <- create_distribution_plot(final_data, "vindict_score")
print(plot_vin)
```

```{r}
# For your original example
plot_dec <- create_distribution_plot(final_data, "deceit_score")
print(plot_dec)
```

```{r}
# For your original example
plot_cal <- create_distribution_plot(final_data, "callous_score")
print(plot_cal)
```

```{r}
# For your original example
plot_sad <- create_distribution_plot(final_data, "sadism_score")
print(plot_sad)
```







```{r}
# correlate d_levels and other subscores 
sub_scores <- final_data %>% group_by(d_level) %>% summarise (mean_cal = mean(callous_score),
                                                mean_dec = mean(deceit_score),
                                                mean_sad = mean(sadism_score),
                                                mean_vin = mean(vindict_score))

sub_scores
```

## Mean investment and return per round



```{r}
library(dplyr)
library(tidyr)
library(lme4)
library(broom.mixed)
library(ggplot2)

# 1. Overall differences between high and Low-D participants
summary_stats <- final_data %>%
  group_by(d_level) %>%
  summarise(
    mean_investment = mean(investment, na.rm = TRUE),
    sd_investment = sd(investment, na.rm = TRUE),
    mean_return = mean(return, na.rm = TRUE),
    sd_return = sd(return, na.rm = TRUE),
    mean_return_pct = mean(return_pct, na.rm = TRUE),
    sd_return_pct = sd(return_pct, na.rm = TRUE),
    n = n()
  )

print("Overall Summary Statistics by D-factor Level:")
print(summary_stats)

# Simple t-tests for overall differences
t_test_investment <- t.test(investment ~ d_level, data = final_data)
t_test_return <- t.test(return ~ d_level, data = final_data)
t_test_return_pct <- t.test(return_pct ~ d_level, data = final_data)

print("T-test for Investment by D-factor:")
print(t_test_investment)

print("T-test for Return by D-factor:")
print(t_test_return)

print("T-test for Return Percentage by D-factor:")
print(t_test_return_pct)

```

```{r}
library(lme4)
library(lmerTest)
library(emmeans)


# Test if differences increase in later rounds
# Create early vs late game periods (excluding end-game)
final_data <- final_data %>%
  mutate(game_period = case_when(
    roundNum <= 8 ~ "early",
    roundNum > 8 & roundNum <= 16 ~ "mid",
    roundNum > 16 ~ "late"
  ))



# Create factor variables 
final_data$game_period <- factor(final_data$game_period, levels = c("early", "mid", "late"))
final_data$d_level <- factor(final_data$d_level)

# Remove last round as it is a different game: 

data24 <- final_data %>% filter (roundNum < 25)

# For HMM investments
investment_means <- data24 %>%
  group_by(d_level, game_period) %>%
  summarize(
    mean_investment = mean(investment, na.rm = TRUE),
    sd_investment = sd(investment, na.rm = TRUE),
    n = n(),
    se_investment = sd_investment / sqrt(n)
  )

# For absolute returns
return_means <- data24 %>%
  group_by(d_level, game_period) %>%
  summarize(
    mean_return = mean(return, na.rm = TRUE),
    sd_return = sd(return, na.rm = TRUE),
    n = n(),
    se_return = sd_return / sqrt(n)
  )

# For percentage returns
pct_return_means <- data24 %>%
  group_by(d_level, game_period) %>%
  summarize(
    mean_pct_return = mean(return_pct, na.rm = TRUE),
    sd_pct_return = sd(return_pct, na.rm = TRUE),
    n = n(),
    se_pct_return = sd_pct_return / sqrt(n)
  )

# T-tests for each period
t_test_results <- list()
for(period in c("early", "mid", "late")) {
  # Investment t-test
  inv_data <- data24 %>% filter(game_period == period)
  t_inv <- t.test(investment ~ d_level, data = inv_data)
  
  # Return t-test
  ret_data <- data24 %>% filter(game_period == period)
  t_ret <- t.test(return ~ d_level, data = ret_data)
  
  # Percent return t-test
  pct_data <- data24 %>% filter(game_period == period)
  t_pct <- t.test(return_pct ~ d_level, data = pct_data)
  
  t_test_results[[period]] <- list(
    investment = t_inv,
    return = t_ret,
    pct_return = t_pct
  )
}

# Print results
print(investment_means)
print(return_means)
print(pct_return_means)
print(t_test_results)

```





On average, investments and returns fell within the documented range of 40-60% of the endowment for investments and 35-50% of the total yield for returns, as reported in previous studies [@Charness2008; @Fiedler2011].


Comparing High-D versus Low-D participants across all rounds, we observed several behavioral differences. High-D participants received lower investments (`r papaja::apa_print(t_test_investment)$statistic`) and consistently returned less money to investors (`r papaja::apa_print(t_test_return)$statistic`). The difference in return percentage was statistically significant (`r papaja::apa_print(t_test_return_pct)$statistic`), with High-D participants returning approximately 2-4 percentage points less of the tripled investment. 


To examine how trust behavior evolved over time, we divided the 25-round game into three approximately equal periods—early (rounds 1–8), mid (rounds 9–16), and late (rounds 17–24). This tripartite split allows us to track temporal dynamics while ensuring each period contains a similar number of rounds. The final round (round 25) was excluded due to endgame effects that could distort typical behavior. We compared HMM investments, absolute returns, and percentage returns between the two groups using Welch's t-tests. We excluded the last round and analysed that data separately as participants were told it was the last interaction in that round. 

As shown in Figure \@ref(fig:gamesPlot2), whilst there were no significant difference in investment received and percentage returns sent by the participants between High-D and Low-D groups during early and mid periods, significant differences emerged for all three measures during the late period. The HMM invested significantly *less* in High-D participants than Low-D participants (`r sprintf("t(%1.2f) = %1.2f, p = %1.3e", t_test_results$late$investment$parameter, t_test_results$late$investment$statistic, t_test_results$late$investment$p.value)`). Furthermore, High-D participants sent back significantly lower absolute returns (`r sprintf("t(%1.2f) = %1.2f, p = %1.3e", t_test_results$late$return$parameter, t_test_results$late$return$statistic, t_test_results$late$return$p.value)`) and lower percentage returns (`r sprintf("t(%1.2f) = %1.2f, p = %1.3e", t_test_results$late$pct_return$parameter, t_test_results$late$pct_return$statistic, t_test_results$late$pct_return$p.value)`) compared to Low-D participants.


```{r}
# Set professional color palette
high_d_color <- "#E64B35"  # red
low_d_color <- "#4DBBD5"   # blue

# Prepare data for plotting
plot_data <- data24 %>%
  group_by(d_level, game_period) %>%
  summarise(
    mean_investment = mean(investment, na.rm = TRUE),
    se_investment = sd(investment, na.rm = TRUE) / sqrt(n()),
    mean_return = mean(return, na.rm = TRUE),
    se_return = sd(return, na.rm = TRUE) / sqrt(n()),
    mean_return_pct = mean(return_pct, na.rm = TRUE),
    se_return_pct = sd(return_pct, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

# Create corrected significance data based on the t-test results you provided
# Only include rows where significance exists
sig_data <- data.frame(
  measure = c("return", "return", "investment", "return", "return_pct"),
  game_period = c("early", "mid", "late", "late", "late"),
  sig = c("*", "*", "***", "***", "***"),
  # Position slightly above the highest point in each period for each measure
  y_pos = c(
    max(plot_data$mean_return[plot_data$game_period == "early"]) + 0.5,
    max(plot_data$mean_return[plot_data$game_period == "mid"]) + 0.5,
    max(plot_data$mean_investment[plot_data$game_period == "late"]) + 0.5,
    max(plot_data$mean_return[plot_data$game_period == "late"]) + 0.5,
    max(plot_data$mean_return_pct[plot_data$game_period == "late"]) + 0.015
  )
)

# Nice labels for game periods
period_labels <- c(
  "early" = "Early\n(1-8)",
  "mid" = "Middle\n(9-16)",
  "late" = "Late\n(17-24)"
)

# Define a consistent theme optimized for PDF output
pdf_theme <- theme_bw() +
  theme(
    text = element_text(size = 8),
    plot.title = element_text(size = 9, face = "bold"),
    plot.subtitle = element_text(size = 7),
    axis.title = element_text(size = 8),
    axis.text = element_text(size = 7),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(linewidth = 0.5),
    legend.position = "none",
    plot.margin = margin(3, 5, 3, 5)
  )

# 1. Investment plot
# p1 <- ggplot(plot_data, aes(x = game_period, y = mean_investment, 
#                            group = d_level, color = d_level, shape = d_level)) +
#   geom_line(linewidth = 0.7) +
#   geom_point(size = 2) +
#   geom_errorbar(aes(ymin = mean_investment - se_investment, 
#                    ymax = mean_investment + se_investment), 
#                width = 0.15, linewidth = 0.4) +
#   # Add significance markers only where significant
#   geom_text(data = filter(sig_data, measure == "investment"), 
#            aes(x = game_period, y = y_pos, label = sig),
#            inherit.aes = FALSE,
#            size = 2.5, vjust = -0.5) +
#   scale_x_discrete(labels = period_labels) +
#   scale_color_manual(values = c("high_D" = high_d_color, "low_D" = low_d_color),
#                     labels = c("high_D" = "Low-D", "low_D" = "Low-D")) +
#   scale_shape_manual(values = c("high_D" = 17, "low_D" = 16),
#                     labels = c("high_D" = "Low-D", "low_D" = "Low-D")) +
#   # Set y limits to provide room for significance markers
#   ylim(9.4, 11.7) +
#   labs(
#     title = "A. HMM Investment",
#     subtitle = "Amount invested by HMM agent",
#     y = "Mean Investment (points)",
#     x = NULL
#   ) +
#   # Add legend to top panel
#   theme(legend.position = c(0.8, 0.85),
#         legend.background = element_rect(fill = "white", linewidth = 0.2, color = "gray80"),
#         legend.title = element_blank(),
#         legend.text = element_text(size = 6),
#         legend.key.size = unit(0.5, "lines"),
#         legend.margin = margin(1, 1, 1, 1)) +
#   pdf_theme

# 1. Investment plot
p1 <- ggplot(plot_data, aes(x = game_period, y = mean_investment, 
                            group = d_level, color = d_level, shape = d_level)) +
  geom_line(linewidth = 0.7) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = mean_investment - se_investment, 
                    ymax = mean_investment + se_investment), 
                width = 0.15, linewidth = 0.4) +
  # Add significance markers only where significant
  geom_text(data = filter(sig_data, measure == "investment"), 
            aes(x = game_period, y = y_pos, label = sig),
            inherit.aes = FALSE,
            size = 2.5, vjust = -0.5) +
  scale_x_discrete(labels = period_labels) +
  
  # Corrected scales with proper labels and a shared name to ensure legends merge
  scale_color_manual(name = "Condition",
                     values = c("high_D" = high_d_color, "low_D" = low_d_color),
                     labels = c("high_D" = "High-D", "low_D" = "Low-D")) + # Corrected label
  scale_shape_manual(name = "Condition",
                     values = c("high_D" = 17, "low_D" = 16),
                     labels = c("high_D" = "High-D", "low_D" = "Low-D")) + # Corrected label
  
  # Set y limits to provide room for significance markers
  ylim(9.4, 11.7) +
  labs(
    title = "A. HMM Investment",
    subtitle = "Amount invested by HMM agent",
    y = "Mean Investment (points)",
    x = NULL
  ) +
  # Apply base theme FIRST
  pdf_theme + 
  # THEN, override the legend position for this specific plot
  theme(
    legend.position = c(0.2, 0.85),
    legend.background = element_rect(fill = "white", linewidth = 0.2, color = "gray80"),
    legend.title = element_blank(), # Hides the legend title ("Condition")
    legend.text = element_text(size = 6),
    legend.key.size = unit(0.5, "lines"),
    legend.margin = margin(1, 1, 1, 1)
  )

# 2. Return plot
p2 <- ggplot(plot_data, aes(x = game_period, y = mean_return, 
                           group = d_level, color = d_level, shape = d_level)) +
  geom_line(linewidth = 0.7) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = mean_return - se_return, 
                   ymax = mean_return + se_return), 
               width = 0.15, linewidth = 0.4) +
  # Add significance markers only where significant
  geom_text(data = filter(sig_data, measure == "return"), 
           aes(x = game_period, y = y_pos, label = sig),
           inherit.aes = FALSE,
           size = 2.5, vjust = -0.5) +
  scale_x_discrete(labels = period_labels) +
  scale_color_manual(values = c("high_D" = high_d_color, "low_D" = low_d_color)) +
  scale_shape_manual(values = c("high_D" = 17, "low_D" = 16)) +
  # Set y limits to provide room for significance markers
  ylim(13.2, 18) +
  labs(
    title = "B. Participant Return",
    subtitle = "Amount returned by participants",
    y = "Mean Return (points)",
    x = NULL
  ) +
  pdf_theme

# 3. Return percentage plot
p3 <- ggplot(plot_data, aes(x = game_period, y = mean_return_pct, 
                           group = d_level, color = d_level, shape = d_level)) +
  geom_line(linewidth = 0.7) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = mean_return_pct - se_return_pct, 
                   ymax = mean_return_pct + se_return_pct), 
               width = 0.15, linewidth = 0.4) +
  # Add significance markers only where significant
  geom_text(data = filter(sig_data, measure == "return_pct"), 
           aes(x = game_period, y = y_pos, label = sig),
           inherit.aes = FALSE,
           size = 2.5, vjust = -0.5) +
  # Add significance note inside the plot at the bottom
  annotate("text", x = "early", y = 0.41, 
           label = "* p < 0.05, ** p < 0.01, *** p < 0.001", 
           size = 2, hjust = 0, fontface = "italic") +
  scale_x_discrete(labels = period_labels) +
  scale_color_manual(values = c("high_D" = high_d_color, "low_D" = low_d_color)) +
  scale_shape_manual(values = c("high_D" = 17, "low_D" = 16)) +
  # Use percentage labels
  # scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  # # Set y limits to provide room for significance markers
  # ylim(0.41, 0.47) +
  scale_y_continuous(
  labels = scales::percent_format(accuracy = 1),
  limits = c(0.41, 0.47)) + 
  labs(
    title = "C. Return Percentage",
    subtitle = "Proportion of tripled investment returned",
    y = "Return Percentage",
    x = NULL
  ) +
  pdf_theme

# Combine plots with better aspect ratio for PDF
combined_plot <- plot_grid(
  p1, p2, p3, 
  ncol = 1, 
  align = 'v',
  axis = 'lr',
  rel_heights = c(1, 1, 1.1)
)

```


```{r gamesPlot2, include=T, echo=FALSE, warning =FALSE, fig.width=6, fig.height=8, out.width='0.9\\linewidth', fig.cap="Investment and return patterns across both HMM types and over the 3 game periods by D-factor level. (A) Mean investments from HMM agents decrease for High-D participants in late game periods. (B) Absolute returns similarly decrease for High-D participants. (C) Return percentages show High-D participants consistently return a smaller proportion of received investments, with the difference becoming significant in later periods. Error bars represent standard errors of the mean. This pattern demonstrates how High-D participants' decreasing reciprocity triggers defensive responses from HMM agents."}

# Return the plot
combined_plot
```







<!-- ### Last round analysis  -->



```{r}
# Get last round returns
last_round_data <- final_data %>%
  filter(isLastRound == TRUE) %>%
  dplyr::select(playerId, d_level, callous_score, deceit_score, sadism_score, vindict_score,  investment,return, return_pct)

# Calculate means by D-factor group
means <- last_round_data %>%
  group_by(d_level) %>%
  summarise(
    n = n(),
    mean_return = mean(return),
    sd_return = sd(return)
  )
print("Means by D-factor group:")
print(means)


# For absolute returns
t.test(return ~ d_level, data = last_round_data)

# For return percentages
t.test(return_pct ~ d_level, data = last_round_data)

# Mann-Whitney U tests (non-parametric alternative)
# For absolute returns
wilcox.test(return ~ d_level, data = last_round_data)

# For return percentages
 wilcox.test(return_pct ~ d_level, data = last_round_data)
 

```

## Last Round Analysis



In the last round, High-D participants sent back significantly lower absolute returns than Low-D participants (`r sprintf("t(%1.2f) = %1.2f, p = %1.3f", t.test(return ~ d_level, data = last_round_data)$parameter, t.test(return ~ d_level, data = last_round_data)$statistic, t.test(return ~ d_level, data = last_round_data)$p.value)`); `r sprintf("Wilcoxon W = %1.0f, p = %1.3f", wilcox.test(return ~ d_level, data = last_round_data)$statistic, wilcox.test(return ~ d_level, data = last_round_data)$p.value)`). Similarly, High-D participants sent back a significantly lower percentage of the tripled investment (`r sprintf("t(%1.2f) = %1.2f, p = %1.3f", t.test(return_pct ~ d_level, data = last_round_data)$parameter, t.test(return_pct ~ d_level, data = last_round_data)$statistic, t.test(return_pct ~ d_level, data = last_round_data)$p.value)`); `r sprintf("Wilcoxon W = %1.0f, p = %1.3f", wilcox.test(return_pct ~ d_level, data = last_round_data)$statistic, wilcox.test(return_pct ~ d_level, data = last_round_data)$p.value)`). Both parametric (t-test) and non parametric tests (Wilcoxon) show significant differences.

<!-- ### proportion of states by round and opponent  -->
```{r}
# Calculate proportions of states for each round and opponent
state_props <- final_data %>%
  group_by(opponent.f, roundNum, investorState.f, d_level) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(opponent.f, roundNum) %>%
  mutate(proportion = count / sum(count))

# Create stacked bar plot
ggplot(state_props, aes(x = roundNum, y = proportion, fill = investorState.f)) +
  geom_bar(stat = "identity") +
  facet_wrap(~opponent.f*d_level) +
  scale_fill_manual(values = c("unhappy" = "red", "neutral" = "green", "happy" = "blue")) +
  labs(x = "Round Number", 
       y = "Proportion",
       title = "Distribution of Investor States by Round and Opponent Type",
       fill = "Investor State") +
  theme_minimal()
```

## Total Payoff Analysis


```{r}
# Reshape data to get one row per game per participant
payoff_data <- final_data  %>%
  dplyr::select(playerId, d_level,cal_scaled, dec_scaled, sad_scaled, vin_scaled, opponent.f, gameNum.f, volatile_first, payoffTrust1, payoffTrust2,) %>%
  distinct() %>%
   mutate(
      payoff = case_when(
        gameNum.f == "first game" ~ payoffTrust1,
        gameNum.f == "second game" ~ payoffTrust2
      )
    ) %>%
    dplyr::select(-payoffTrust1, -payoffTrust2)  # Remove unused columns


# Calculate total payoff per participant
total_payoffs <- payoff_data %>%
  group_by(playerId, d_level) %>%
  summarise(total_payoff = sum(payoff, na.rm = TRUE))

# T-test
t_test_payoff <- t.test(total_payoff ~ d_level, data = total_payoffs)

# Wilcoxon test
wilcoxon_test_payoff <- wilcox.test(total_payoff ~ d_level, data = total_payoffs)
```
```{r}
# --- 2. Fit Linear Mixed-Effects Model ---
# This model predicts 'payoff' based on the fixed effects of 'd_level',
# 'opponent.f', and their interaction (d_level * opponent.f).
# It includes a random intercept for 'playerId' to account for
# non-independence of observations from the same participant.
lmm_model <- lmer(payoff ~ d_level * opponent.f + (1 | playerId), data = payoff_data)

# --- 3. Print Model Summary ---
# The summary provides estimates, standard errors, t-values, and p-values
# for the fixed effects, including the interaction term.
# A significant interaction term suggests the effect of d_level on payoff
# differs depending on the opponent type.
print(summary(lmm_model))

# Optional: Print ANOVA table for F-tests of fixed effects
# print(anova(lmm_model))
```

```{r}
# --- Perform post-hoc tests for the interaction ---
# Compare the levels of 'd_level' for each level of 'opponent.f'
# Adjust p-values using the default Tukey method for multiple comparisons if needed,
# though with only two comparisons here, adjustment might not change much. Use adjust="none" if preferred.
posthoc_emm <- emmeans(lmm_model, pairwise ~ d_level | opponent.f, adjust = "tukey")

# --- Print the results ---
print(summary(posthoc_emm, infer = TRUE)) # Shows EMMs and pairwise comparisons with CIs and p-values

# You specifically want the 'contrasts' part of the output for reporting
print(posthoc_emm$contrasts)
```




Finally, we analysed the total payoffs earned by participants across both games, comparing High-D and Low-D individuals. This analysis aimed to determine whether differences in strategy observed during the game (particularly in the later periods) translated into overall differences in earnings. We used a Welch's t-test and a Wilcoxon rank-sum test.

The results showed no significant difference in total payoffs between High-D and Low-D participants (`r sprintf("t(%1.2f) = %1.2f, p = %1.3f", t_test_payoff$parameter, t_test_payoff$statistic, t_test_payoff$p.value)`; `r sprintf("Wilcoxon W = %1.0f, p = %1.3f", wilcoxon_test_payoff$statistic, wilcoxon_test_payoff$p.value)`).

Although High-D participants sent back lower returns in the late period of the trust game, their total accumulated payoff across all rounds was not significantly different from that of Low-D participants.  This seemingly paradoxical result can be explained by the adaptive behavior of the HMM opponent.  While High-D individuals adopted a less cooperative strategy in later rounds, keeping a larger portion of the returns for themselves, the HMM responded by reducing its investments in these individuals.  Therefore, the higher proportion kept by High-D participants was offset by a reduction in the amount they received, leading to similar overall earnings compared to the more cooperative Low-D participants.


<!-- #### Payoff regression with sub-scales of D factor -->

```{r}
mod_payoffs_cal <- mixed( payoff ~ opponent.f*cal_scaled*volatile_first + (1| playerId), payoff_data, REML= TRUE, method="KR")
anova(mod_payoffs_cal)

mod_payoffs_sad <- mixed( payoff ~ opponent.f*sad_scaled*volatile_first + (1| playerId), payoff_data, REML= TRUE, method="KR")
anova(mod_payoffs_sad)

mod_payoffs_dec <- mixed( payoff ~ opponent.f*dec_scaled*volatile_first + (1| playerId), payoff_data, REML= TRUE, method="KR")
anova(mod_payoffs_dec)

mod_payoffs_vin <- mixed( payoff ~ opponent.f*vin_scaled*volatile_first + (1| playerId), payoff_data, REML= TRUE, method="KR")
anova(mod_payoffs_vin)


```

```{r}
# Split data by opponent type and run correlation between vin_scaled and payoff
by(payoff_data, payoff_data$opponent.f, function(x) {
    cor.test(x$vin_scaled, x$payoff)
})

# Create simple scatter plots
library(ggplot2)
ggplot(payoff_data, aes(x = vin_scaled, y = payoff, color = opponent.f)) +
    geom_point() +
    geom_smooth(method = "lm") +
    facet_wrap(~opponent.f)
```

```{r}
# For simple slopes analysis for interaction between vindictiveness and Opponent type 
library(emmeans)

# Get marginal means at ±1 SD of vindictiveness for each opponent
emm <- emmeans(mod_payoffs_vin, 
               ~ opponent.f | vin_scaled, 
               at = list(vin_scaled = c(-1, 0, 1)))  # -1/+1 SD and mean
pairs(emm)

# Look at opponent effect at different levels of vindictiveness
emm_slopes <- emtrends(mod_payoffs_vin, 
                       ~ opponent.f, 
                       var = "vin_scaled")
pairs(emm_slopes)
```

## Round by round analysis 

```{r lmem, cache=T}
# Maximal random effect structure
mod_return_pct <- afex::mixed(ret_pct_na ~ opponent.f*inv_scaled*d_level*volatile_first*roundNum + 
      (1 + opponent.f + inv_scaled | playerId), 
      data = data24, 
      REML = TRUE, 
      method = "KR")

anova(mod_return_pct)

# Save the model object to a file
saveRDS(mod_return_pct, file = "data/mod_return_pct.RDS")

```


To analyse participants behavior on a round by round basis, we look at the fit results from the linear mixed effects model of participant percentage returns detailed in the Methods section.



### Main Effects

We found a significant main effect of investment amount (`r papaja::apa_print(mod_return_pct)$full_result$inv_scaled`), with participants returning higher percentages when they received larger investments, demonstrating positive reciprocity. We also found a significant main effect of round number (`r papaja::apa_print(mod_return_pct)$full_result$roundNum`), showing that return percentages generally decreased over time as the game progressed.


### D-Factor by Round Number Interaction

```{r}
# Analyze slope differences by D-factor level
d_level_trends <- emmeans::emtrends(mod_return_pct, ~ d_level, var = "roundNum")
d_level_trends_test <- summary(d_level_trends)
d_level_trends_contrast <- contrast(d_level_trends, "pairwise")

d_level_trends 
d_level_trends_test 
d_level_trends_contrast 

# Generate predicted data for plotting
round_range <- 1:24
c<- emmeans::emmip(
  mod_return_pct,
  d_level ~ roundNum,
  at = list(roundNum = round_range),
  type = "response",
  CIs = TRUE,
  plotit = FALSE
)

```

```{r}
# Generate predictions across a range of roundNum values, say from 1 to 24
#   (the length of your experiment). You can vary this sequence as needed.
round_range <- 1:24

# We use emmip to predict how ret_pct_na changes over roundNum by d_level
plot_data <- emmip(
  mod_return_pct,
  d_level ~ roundNum,
  at = list(roundNum = round_range),
  type = "response",   # 'response' will back-transform if link functions are involved
  CIs = TRUE,
  plotit = FALSE
)

# Inspect the data frame of predicted values
head(plot_data)

# Now, plot using ggplot2
ggplot(plot_data, aes(x = roundNum, y = yvar, color = d_level, group = d_level)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = LCL, ymax = UCL, fill = d_level),
              alpha = 0.2, color = NA) +
  labs(
    x = "Round Number",
    y = "Predicted Return Proportion",
    color = "D-level",
    fill = "D-level",
    title = "Effect of Round Number by D-level on Return Proportion"
  ) +
  theme_minimal(base_size = 14)

```
We found a significant interaction between D-factor and round number (`r papaja::apa_print(mod_return_pct)$full_result$d_level_roundNum`). Participants with High-D scores demonstrated a significant negative slope in their return proportions as the game progressed, indicating a systematic decrease in reciprocity over time (slope = `r sprintf("%.4f", d_level_trends_test$roundNum.trend[1])`, 95% CI [`r sprintf("%.4f", d_level_trends_test$asymp.LCL[1])`, `r sprintf("%.4f", d_level_trends_test$asymp.UCL[1])`]). In contrast, participants with Low-D scores maintained relatively stable return rates across rounds, with a slope not significantly different from zero. The difference between these slopes was statistically significant (`r sprintf("z = %.2f, p = %.3f", summary(d_level_trends_contrast)$z.ratio, summary(d_level_trends_contrast)$p.value)`).


### D-Factor, Opponent Type and Investment Interaction



```{r emtrends_calcs, include=FALSE}
library(emmeans)
# Get the slopes (effects of investment) for each combination
slopes <- emtrends(mod_return_pct, ~ opponent.f * d_level, var = "inv_scaled")
slopes_summary <- summary(slopes, infer = TRUE)
slopes_summary 

# # Define the contrasts
# contrasts <- list(
#   "Investment effect: High vs Low-D in Human-like HMM" = c(-1, 1, 0, 0),
#   "Investment effect: High vs Low-D in Volatile HMM" = c(0, 0, -1, 1),
#   "Opponent effect: Human vs Volatile in Low-D" = c(-1, 0, 1, 0),
#   "Opponent effect: Human vs Volatile in High D" = c(0, -1, 0, 1)
# )
# 
# # Test the contrasts with multiple comparison correction
# results_3w <- contrast(slopes, method = contrasts, adjust = "sidak")
# results_3w
```



Low-D participants showed significant positive reciprocity with both opponents: a one-unit increase in investment led to a significant increase in return percentage for both the Human-like HMM (`r sprintf("%.1f%%", 100*slopes_summary$inv_scaled.trend[3])`, *p* = `r sprintf("%.3f", slopes_summary$p.value[3])`) and the Responsive HMM (`r sprintf("%.1f%%", 100*slopes_summary$inv_scaled.trend[4])`, *p* = `r sprintf("%.3f", slopes_summary$p.value[4])`).

In contrast, High-D participants did *not* show significant reciprocity with either the Human-like HMM (slope = `r sprintf("%.3f", slopes_summary$inv_scaled.trend[1])`, *p* = `r sprintf("%.3f", slopes_summary$p.value[1])`) or the Responsive HMM (slope = `r sprintf("%.3f", slopes_summary$inv_scaled.trend[2])`, *p* = `r sprintf("%.3f", slopes_summary$p.value[2])`), indicating their returns were less influenced by investment amount.


```{r}
# Define a range of 'inv_scaled' values.
inv_seq <- seq(-1.5, 1.5, by = 0.1)

# Pick a mid-round value (e.g., round = 12 or the mean), 
# and hold volatile_first to a single level if appropriate.
plot_data <- emmip(
  mod_return_pct,
  # Formula: "opponent.f ~ inv_scaled | d_level" means:
  #   - x-axis will be inv_scaled
  #   - lines will be opponent.f
  #   - separate facets for d_level
  opponent.f ~ inv_scaled | d_level,  
  at = list(inv_scaled = inv_seq,
            roundNum   = 12,        
            volatile_first = FALSE),  
  type = "response",  # get predictions on the original scale (ret_pct_na proportion)
  CIs = TRUE,         # get confidence intervals
  plotit = FALSE      # return data instead of plotting
)

# Inspect the first few rows
head(plot_data)

```

```{r}
ggplot(plot_data, aes(x = inv_scaled, y = yvar,
                      color = opponent.f, group = opponent.f)) +
  # Add a line for each level of opponent.f
  geom_line(size = 1.2) +
  # Add ribbons for CI 
  geom_ribbon(
    aes(ymin = LCL, ymax = UCL, fill = opponent.f),
    alpha = 0.15, color = NA
  ) +
  # Facet by d_level (High vs. Low)
  facet_wrap(~ d_level) +
  labs(
    x = "Scaled Investment (inv_scaled)",
    y = "Predicted Return Proportion",
    color = "Opponent",
    fill  = "Opponent",
    title = "Opponent x Investment x D-level Interaction"
  ) +
  theme_minimal(base_size = 14)

```

```{r}
# Obtain the slopes for inv_scaled for each combination of opponent.f and d_level
inv_slopes <- emtrends(
  mod_return_pct,
  pairwise ~ opponent.f * d_level,  # or simply ~ opponent.f:d_level
  var = "inv_scaled",
  adjust = "tukey"  # or "tukey", "fdr", "none", etc.
)

# Show summary of slopes for each condition
summary(inv_slopes$emtrends)

# Show pairwise tests among those slopes (with chosen correction)
inv_slopes$contrasts

```


### Four-Way Interaction: Opponent, Investment, D-factor, and Round Number



```{r}
# Look at investment slopes at different time points
emtrends(mod_return_pct, 
         ~ d_level*opponent.f, 
         var = "inv_scaled",
         at = list(roundNum = seq(1, 20, by = 5)))  # Examine trend across multiple rounds
```

```{r}
# Look at round slopes at different investment levels
# Get slopes at different investment levels
emtrends(mod_return_pct, 
         ~ d_level*opponent.f*inv_scaled, 
         var = "roundNum",
         at = list(inv_scaled = c(-1, 0, 1)))
```

```{r}
# Test whether slopes differ between investment levels
emtrends_round <- emtrends(mod_return_pct, 
         pairwise ~ inv_scaled | d_level*opponent.f, 
         var = "roundNum",
         at = list(inv_scaled = c(-1, 0, 1)))

emtrends_round 

relevant_contrast <- summary(emtrends_round$contrasts, infer = TRUE)[1,]
relevant_contrast

# Get the slopes and CIs for High-D, human-like, high and low investment
high_d_human_slopes <- summary(emtrends_round$emtrends, infer = TRUE)
high_d_human_high_inv <- high_d_human_slopes[3,] #high inv
high_d_human_low_inv <- high_d_human_slopes[1,] #low inv

```


```{r}
# Get the emtrends results
trends <- emtrends(mod_return_pct, 
                  ~ d_level*opponent.f*inv_scaled, 
                  var = "roundNum",
                  at = list(inv_scaled = c(-1, 0, 1)))

# Convert to data frame and organize
trend_data <- as.data.frame(trends) %>%
  mutate(
    d_level = factor(d_level),
    opponent = opponent.f,
    inv_level = factor(case_when(
      inv_scaled == -1 ~ "Low (-1 SD)",
      inv_scaled == 0 ~ "Medium (0)",
      inv_scaled == 1 ~ "High (+1 SD)"
    ), levels = c("Low (-1 SD)", "Medium (0)", "High (+1 SD)")),
    lower = roundNum.trend - (1.96 * SE),
    upper = roundNum.trend + (1.96 * SE)
  ) %>%
  rename(slope = roundNum.trend)


```


```{r oppExploit, include=T, warning=F, echo=F, fig.cap="Changes in return rate over successive rounds by investment level, opponent type, and D-factor group. Bars represent the estimated slope coefficients (change in return percentage per round) with error bars showing 95 percent confidence intervals. Negative values indicate decreasing reciprocity over time. High-D participants show more pronounced decreases in return rates, particularly with the human-like opponent at high investment levels, suggesting they learned strategic exploitation of predictable, trusting partners.", fig.align="center", fig.width=10,fig.height=6, out.width="\\textwidth"}

# Create plot with points instead of bars and revised color scheme


ggplot(trend_data, aes(inv_level, slope, color = opponent, shape = opponent)) +
  geom_point(size = 3, position = position_dodge(0.3)) +
  geom_errorbar(aes(ymin = lower, ymax = upper),
                position = position_dodge(0.3), width = 0.2) +
  geom_line(aes(group = opponent), position = position_dodge(0.3)) +
  facet_wrap(~d_level, 
             labeller = labeller(d_level = c(high_D = "High-D", low_D = "Low-D"))) +
  scale_color_manual(
    values = c(AI_HMM = "#1b9e77", AI_HMM_vol = "#d95f02"),
    labels = c(AI_HMM = "Human-like", AI_HMM_vol = "Responsive")
  ) +
  scale_shape_manual(
    values = c(AI_HMM = 16, AI_HMM_vol = 17),
    labels = c(AI_HMM = "Human-like", AI_HMM_vol = "Responsive")
  ) +
  labs(
    x     = "Investment Level (standardized)",
    y     = "Change in Return Rate per Round",
    color = "Opponent Type",
    shape = "Opponent Type"
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  theme_classic(base_size = 12) +
  theme(
    # Tweak axis titles/text
    axis.text       = element_text(size = 10),
    axis.title.x    = element_text(margin = margin(t = 8)),
    strip.text      = element_text(size = 11),
    strip.background= element_rect(fill = "white", color = "black"),
    panel.grid.major.y = element_line(color = "gray90"),

    # Single‐row, inside‐panel legend
    legend.position      = c(0.75, 0.08),   # x=75% across, y=4% up from bottom
    legend.justification = c(0.5, 0),      # anchor middle bottom
    legend.direction     = "horizontal",   # lay out keys in a row
    legend.box.margin    = margin(2,2,2,2),# small padding
    legend.background    = element_rect(fill = alpha("white", 0.2), color = "gray80"),
    legend.key           = element_blank(),# no box around each key
    legend.spacing.x     = unit(0.7, "lines"),
    legend.title         = element_text(face = "bold", size = 9),
    legend.text          = element_text(size = 9)
  ) +
  guides(
    color = guide_legend(nrow = 1, byrow = TRUE),
    shape = guide_legend(nrow = 1, byrow = TRUE)
  )
```




Analysis of the significant four-way interaction (`r papaja::apa_print(mod_return_pct)$full_result$opponent_f_inv_scaled_d_level_roundNum`), visualised in Figure \@ref(fig:oppExploit), revealed that only High-D participants facing the human-like opponent showed investment-dependent changes in behavior across rounds (`r sprintf("p = %.3f", relevant_contrast$p.value)`). For these participants, returns decreased significantly across rounds with high investments (slope = `r sprintf("%.5f", high_d_human_high_inv$roundNum.trend)`, 95% CI [`r sprintf("%.5f", high_d_human_high_inv$asymp.LCL)`, `r sprintf("%.5f", high_d_human_high_inv$asymp.UCL)`]), but remained stable with low investments (slope = `r sprintf("%.5f", high_d_human_low_inv$roundNum.trend)`, 95% CI [`r sprintf("%.5f", high_d_human_low_inv$asymp.LCL)`, `r sprintf("%.5f", high_d_human_low_inv$asymp.UCL)`]), a significant difference in slopes (`r sprintf("p = %.3f", relevant_contrast$p.value)`).

Neither Low-D participants nor High-D participants facing the responsive opponent showed this strategic pattern. This suggests High-D participants specifically exploit a weakness in Human-like opponent strategies (the propensity to remain in a mid-trust state even after receiving lower returns) by systematically reducing reciprocity over time on the most lucrative (high-investment) trials.


```{r}
# Get slopes across finer gradient of investment values
trends_continuous <- emtrends(mod_return_pct, 
                            ~ d_level*volatile_first*inv_scaled, 
                            var = "roundNum",
                            at = list(inv_scaled = seq(-1, 1, by = 0.1)))

# Convert to data frame for plotting
trend_data <- as.data.frame(trends_continuous) %>%
  mutate(
    d_level = factor(d_level),
    volatile_first = factor(volatile_first, labels = c("Human-like First", "Responsive First")),
    lower = roundNum.trend - (1.96 * SE),
    upper = roundNum.trend + (1.96 * SE)
  )


```


```{r orderEffectPlot, include=T, fig.pos="H", fig.cap="Effect of game order on changes in return rate across rounds at different investment levels. Lines represent the estimated slope coefficients (change in return rate per round) with shaded areas showing 95 percent confidence intervals. Negative values indicate decreasing reciprocity over time. High-D participants who played against the stable opponent first showed strategic exploitation primarily at high investment levels, while those who faced the volatile opponent first showed different strategic patterns. Low D-factor participants maintained more consistent return rates regardless of order condition.", fig.align="center",  out.width="\\textwidth", dev="pdf", fig.width=10, fig.height=6}

ggplot(trend_data, aes(x = inv_scaled, y = roundNum.trend,
                       color = volatile_first, fill = volatile_first)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, color = NA) +
  facet_wrap(~d_level,
             labeller = labeller(d_level = c(high_D = "High-D", low_D = "Low-D"))) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  scale_color_manual(
    values = c("#7570b3", "#e7298a"),
    labels = c("Human-like First" = "Stable First", "Responsive First" = "Volatile First")
  ) +
  scale_fill_manual(
    values = c("#7570b3", "#e7298a"),
    labels = c("Human-like First" = "Stable First", "Responsive First" = "Volatile First")
  ) +
  labs(
    x     = "Investment Level (Standardized)",
    y     = "Change in Return Rate per Round",
    color = "Order Condition",
    fill  = "Order Condition"
  ) +
  theme_classic(base_size = 12) +
  theme(
    axis.text        = element_text(size = 11),
    axis.title       = element_text(size = 12),
    strip.text       = element_text(size = 12),
    strip.background = element_rect(fill = "white", color = "black"),
    panel.grid.major.y = element_line(color = "gray90"),

    # float a single‐row legend inside the plot
    legend.position      = c(0.2, 0.8),   # centered at bottom
    legend.justification = c(0.4, 0),      # anchor middle‐bottom
    legend.direction     = "horizontal",
     # ** REMOVE ALL BOXES **  
    legend.background       = element_blank(),
    legend.key              = element_blank(),
    legend.box.background   = element_blank(),
    legend.spacing.x     = unit(0.7, "lines"),
    legend.title         = element_text(face = "bold", size = 9),
    legend.text          = element_text(size = 9)
  ) +
  guides(
    color = guide_legend(
      title.position = "left",
      title.hjust    = 0.5,    # center the title next to the keys
      nrow           = 1,
      byrow          = TRUE
    ),
    fill = guide_legend(
      title.position = "left",
      title.hjust    = 0.5,
      nrow           = 1,
      byrow          = TRUE
    )
  ) 


```








### Four-Way Interaction: Investment, Order, D-factor, and Round Number

The significant four-way interaction involving investment amount, order of opponent presentation (responsive first or stable/human-like first), D-factor, and round number (`r papaja::apa_print(mod_return_pct)$full_result$inv_scaled_d_level_volatile_first_roundNum`) reveals a complex interplay of factors influencing return behavior. As seen in Figure \@ref(fig:orderEffectPlot), The key finding is that the *order* in which participants faced the opponents, combined with their D-factor level, influenced how their returns changed over time *depending on the investment level*.

<!-- To disentangle this interaction, we used `emtrends` to examine the simple slopes of return percentage over rounds, for each combination of D-factor, order condition, and investment level. We then used `test()` to determine if these slopes were significantly different from zero. -->

```{r four_way_inv_order_calcs, include=FALSE}
library(emmeans)

# Slopes of return percentage over rounds for each investment level,
#  D-factor, and order condition.
round_slopes <- emtrends(
  mod_return_pct,
  ~ inv_scaled | d_level * volatile_first,
  var = "roundNum",
  at = list(inv_scaled = c(-1, 0, 1))
)

# Test if slopes differ from zero, with Sidak correction for multiple comparisons.
round_slopes_test <- test(round_slopes, null = 0, adjust = "sidak")

get_slope_and_p <- function(test_object, d_level_val, volatile_first_val, inv_scaled_val) {
  # Convert to data frame for easier manipulation
  df <- as.data.frame(test_object)
  
  # Filter for the specific combination
  result_row <- df[df$d_level == d_level_val & 
                  df$volatile_first == volatile_first_val & 
                  df$inv_scaled == inv_scaled_val, ]
  
  # Check if we found a matching row
  if(nrow(result_row) == 0) {
    warning("No matching combination found")
    return(list(slope = NA, p_value = NA))
  }
  
  # Return both the slope and p-value
  return(list(
    slope = result_row$roundNum.trend,
    p_value = result_row$p.value
  ))
}

# Get values for High-D, stable-first
high_D_stable_high <- get_slope_and_p(round_slopes_test, "high_D", FALSE, 1)

high_D_stable_high <- get_slope_and_p(round_slopes_test, "high_D", FALSE, 1)
high_D_stable_med <- get_slope_and_p(round_slopes_test, "high_D", FALSE, 0)
high_D_stable_low <- get_slope_and_p(round_slopes_test, "high_D", FALSE, -1)

# Get values for High-D, responsive-first
high_D_volatile_high <- get_slope_and_p(round_slopes_test, "high_D", TRUE, 1)
high_D_volatile_med <- get_slope_and_p(round_slopes_test, "high_D", TRUE, 0)
high_D_volatile_low <- get_slope_and_p(round_slopes_test, "high_D", TRUE, -1)

# Get values for Low-D, stable-first
low_D_stable_high <- get_slope_and_p(round_slopes_test, "low_D", FALSE, 1)
low_D_stable_med <- get_slope_and_p(round_slopes_test, "low_D", FALSE, 0)
low_D_stable_low <- get_slope_and_p(round_slopes_test, "low_D", FALSE, -1)

# Get values for Low-D, responsive-first
low_D_volatile_high <- get_slope_and_p(round_slopes_test, "low_D", TRUE, 1)
low_D_volatile_med <- get_slope_and_p(round_slopes_test, "low_D", TRUE, 0)
low_D_volatile_low <- get_slope_and_p(round_slopes_test, "low_D", TRUE, -1)

# Helper function for formatting p-values
format_p <- function(p) {
  if (is.na(p)) {
    return("NA")
  } else if (p < 0.001) {
    return("p < .001")
  } else {
    return(sprintf("p = %.3f", p))
  }
}

```




High-D participants who faced the *stable* (human-like) *opponent* *first* showed a strategic pattern: they significantly decreased their returns over rounds for *high* (slope = `r sprintf("%.5f", high_D_stable_high$slope)`, `r format_p(high_D_stable_high$p_value)`) and *medium* investments (slope = `r sprintf("%.5f", high_D_stable_med$slope)`, `r format_p(high_D_stable_med$p_value)`), but not for low investments (slope = `r sprintf("%.5f", high_D_stable_low$slope)`, `r format_p(high_D_stable_low$p_value)`). This reinforces the idea that High-D individuals are more likely to reduce cooperation when they perceive an opportunity for greater gain (higher investments) and an exploitable partner. In contrast, High-D participants who faced the *responsive* *opponent* *first* showed the *opposite* pattern: decreasing returns for *low* (slope = `r sprintf("%.5f", high_D_volatile_low$slope)`, `r format_p(high_D_volatile_low$p_value)`) and *medium* investments (slope = `r sprintf("%.5f", high_D_volatile_med$slope)`, `r format_p(high_D_volatile_med$p_value)`), but not for high investments (slope = `r sprintf("%.5f", high_D_volatile_high$slope)`, `r format_p(high_D_volatile_high$p_value)`).

Low-D participants, regardless of the order in which they faced the opponents, did *not* show significant changes in their returns across rounds for any investment level.



```{r}
library(MuMIn)

# Calculate R-squared
r2_pct <- r.squaredGLMM(mod_return_pct$full_model)

cat("Fixed effects explain", round(r2_pct[1]*100, 1), "% of variance\n")
cat("Fixed and random effects together explain", round(r2_pct[2]*100, 1), "% of variance\n")

# Optional: Calculate the variance explained by random effects alone
cat("Random effects alone explain", round((r2_pct[2] - r2_pct[1])*100, 1), "% of variance\n")
```



## Analysis of opponent ratings 

```{r}
ratings_data <- final_data %>%
  # Extract only the rows with ratings (typically at the end of each game)
  filter(!is.na(rating_cooperative)) %>%
  # Convert to factors where appropriate
  mutate(
    game_order = factor(gameNum.f, levels = c("first game", "second game")),
    opponent_type = case_when(
      grepl("AI_HMM_vol", opponent.f) ~ "Responsive",
      grepl("AI_HMM", opponent.f) ~ "Human-like"
    ),
    opponent_type = factor(opponent_type),
    d_level = factor(d_level)
  ) %>%
  # Select relevant columns
  dplyr::select(playerId, game_order, opponent_type, d_level, 
         rating_cooperative, rating_trusting, rating_playAgain)%>% 
  unique()
```

```{r}
# Function to create consistent rating plots
create_rating_plot <- function(rating_var, rating_name) {
  ggplot(ratings_data, aes(x = game_order, y = {{rating_var}}, 
                         color = d_level, group = interaction(d_level, opponent_type))) +
    stat_summary(fun = mean, geom = "point", size = 3) +
    stat_summary(fun = mean, geom = "line") +
    stat_summary(fun.data = mean_se, geom = "errorbar", width = 0.2) +
    facet_wrap(~opponent_type) +
    labs(title = paste(rating_name, "Ratings by D-level, Game Order, and Opponent Type"),
         x = "Game Order", y = paste(rating_name, "Rating (1-10)"),
         color = "D-level Group") +
    theme_minimal()
}

# Create plots for each rating type
coop_plot <- create_rating_plot(rating_cooperative, "Cooperative")
play_plot <- create_rating_plot(rating_playAgain, "Play Again")
trust_plot <- create_rating_plot(rating_trusting, "Trusting")

# Display plots
print(coop_plot)
print(play_plot)
print(trust_plot)

```


```{r ratingsAfex}
# Step 3: Linear mixed-effects models using afex::mixed

# Load required package for improved mixed model analysis
library(afex)

# Model for cooperative ratings
coop_model_afex <- mixed(
  rating_cooperative ~ d_level * game_order * opponent_type + (1 | playerId),
  data = ratings_data,
  method = "KR"  # Kenward-Roger approximation for degrees of freedom
)

# Model for play again ratings
play_model_afex <- mixed(
  rating_playAgain ~ d_level * game_order * opponent_type + (1 | playerId),
  data = ratings_data,
  method = "KR"
)

# Model for trusting ratings
trust_model_afex <- mixed(
  rating_trusting ~ d_level * game_order * opponent_type + (1 | playerId),
  data = ratings_data,
  method = "KR"
)

# Step 4: Summarize model results
cat("ANOVA results for Cooperative ratings:\n")
print(anova(coop_model_afex))

cat("\nANOVA results for Play Again ratings:\n")
print(anova(play_model_afex))

cat("\nANOVA results for Trusting ratings:\n")
print(anova(trust_model_afex))
```




```{r ratingsEmmeans}
library(emmeans)

# COOPERATIVE RATINGS
# 1. Main effect of D-level
coop_d <- emmeans(coop_model_afex, ~ d_level)
pairs(coop_d, adjust = "tukey")

# 2. Main effect of Game Order
coop_game <- emmeans(coop_model_afex, ~ game_order)
pairs(coop_game, adjust = "tukey")

# 3. Main effect of Opponent Type
coop_opp <- emmeans(coop_model_afex, ~ opponent_type)
pairs(coop_opp, adjust = "tukey")

# PLAY AGAIN RATINGS
# 1. Main effect of Game Order
play_game <- emmeans(play_model_afex, ~ game_order)
pairs(play_game, adjust = "tukey")

# 2. D-level × Game Order interaction
# a) D-level effects within each Game Order
play_d_by_game <- emmeans(play_model_afex, ~ d_level | game_order)
pairs(play_d_by_game, adjust = "tukey")

# b) Game Order effects within each D-level
play_game_by_d <- emmeans(play_model_afex, ~ game_order | d_level)
pairs(play_game_by_d, adjust = "tukey")

# TRUSTING RATINGS
# 1. Main effects (similar to cooperative ratings)
trust_d <- emmeans(trust_model_afex, ~ d_level)
pairs(trust_d, adjust = "tukey")

trust_game <- emmeans(trust_model_afex, ~ game_order)
pairs(trust_game, adjust = "tukey")

trust_opp <- emmeans(trust_model_afex, ~ opponent_type)
pairs(trust_opp, adjust = "tukey")

# 2. Three-way interaction
# a) D-level effects for each Game Order × Opponent Type combination
trust_d_by_game_opp <- emmeans(trust_model_afex, ~ d_level | game_order:opponent_type)
pairs(trust_d_by_game_opp, adjust = "tukey")

# b) Game Order effects for each D-level × Opponent Type combination
trust_game_by_d_opp <- emmeans(trust_model_afex, ~ game_order | d_level:opponent_type)
pairs(trust_game_by_d_opp, adjust = "tukey")

# c) Opponent Type effects for each D-level × Game Order combination
trust_opp_by_d_game <- emmeans(trust_model_afex, ~ opponent_type | d_level:game_order)
pairs(trust_opp_by_d_game, adjust = "tukey")
```





```{r ratingsAPAprint}
library(afex)
library(emmeans)
library(papaja)

# --- Data Loading and Model Fitting (Replace with your actual data loading) ---
# Assuming your data is in a dataframe called 'ratings_data'
# and your models are already fit as coop_model_afex, play_model_afex, trust_model_afex

# --- Cooperative Ratings ---

# ANOVA
coop_anova_results <- apa_print(coop_model_afex, es = "pes")

# 1. Main effect of D-level
coop_d <- emmeans(coop_model_afex, ~ d_level)
coop_d_posthoc <- apa_print(pairs(coop_d, adjust = "tukey"))

# 2. Main effect of Game Order
coop_game <- emmeans(coop_model_afex, ~ game_order)
coop_game_posthoc <- apa_print(pairs(coop_game, adjust = "tukey"))

# 3. Main effect of Opponent Type
coop_opp <- emmeans(coop_model_afex, ~ opponent_type)
coop_opp_posthoc <- apa_print(pairs(coop_opp, adjust = "tukey"))

# --- Play Again Ratings ---

# ANOVA
play_anova_results <- apa_print(play_model_afex, es = "pes")

# 1. Main effect of Game Order
play_game <- emmeans(play_model_afex, ~ game_order)
play_game_posthoc <- apa_print(pairs(play_game, adjust = "tukey"))

# 2. D-level × Game Order interaction
# a) D-level effects within each Game Order
play_d_by_game <- emmeans(play_model_afex, ~ d_level | game_order)
play_d_by_game_posthoc <- apa_print(pairs(play_d_by_game, adjust = "tukey"))

# b) Game Order effects within each D-level
play_game_by_d <- emmeans(play_model_afex, ~ game_order | d_level)
play_game_by_d_posthoc <- apa_print(pairs(play_game_by_d, adjust = "tukey"))

# --- Trusting Ratings ---

# ANOVA
trust_anova_results <- apa_print(trust_model_afex, es = "pes")

# 1. Main effects
trust_d <- emmeans(trust_model_afex, ~ d_level)
trust_d_posthoc <- apa_print(pairs(trust_d, adjust = "tukey"))

trust_game <- emmeans(trust_model_afex, ~ game_order)
trust_game_posthoc <- apa_print(pairs(trust_game, adjust = "tukey"))

trust_opp <- emmeans(trust_model_afex, ~ opponent_type)
trust_opp_posthoc <- apa_print(pairs(trust_opp, adjust = "tukey"))

# 2. Three-way interaction
# a) D-level effects for each Game Order × Opponent Type combination
trust_d_by_game_opp <- emmeans(trust_model_afex, ~ d_level | game_order:opponent_type)
trust_d_by_game_opp_posthoc <- apa_print(pairs(trust_d_by_game_opp, adjust = "tukey"))


# b) Game Order effects for each D-level × Opponent Type combination
trust_game_by_d_opp <- emmeans(trust_model_afex, ~ game_order | d_level:opponent_type)
trust_game_by_d_opp_posthoc <- apa_print(pairs(trust_game_by_d_opp, adjust = "tukey"))

# c) Opponent Type effects for each D-level × Game Order combination
trust_opp_by_d_game <- emmeans(trust_model_afex, ~ opponent_type | d_level:game_order)
trust_opp_by_d_game_posthoc <- apa_print(pairs(trust_opp_by_d_game, adjust = "tukey"))
```

Beyond behavioral measures, we also analysed participants' explicit evaluations of their opponents using linear mixed-effects models. These models assessed ratings of cooperativeness, willingness to play again, and trust based on participants' D-level, the opponent type faced, and the order of games (see Figure \@ref(fig:plotRatings) for a summary).

### Cooperative Ratings

Linear mixed-effects analysis revealed a significant main effect of D-level (`r coop_anova_results$statistic["d_level"]`), with Low-D participants rating their opponents as more cooperative than High-D participants (`r coop_d_posthoc$statistic[1]`). A significant main effect of game order (`r coop_anova_results$statistic["game_order"]`) indicated participants rated opponents in their first game as more cooperative than those in their second game (`r coop_game_posthoc$statistic[1]`). Additionally, there was a significant main effect of opponent type (`r coop_anova_results$statistic["opponent_type"]`), with Human-like HMM opponents receiving higher cooperative ratings than Responsive opponents (`r coop_opp_posthoc$statistic[1]`).

### Play Again Ratings

Analysis of participants' willingness to play with the same opponent again revealed a significant main effect of game order (`r play_anova_results$statistic["game_order"]`), with participants generally more willing to play again with opponents from their first game (`r play_game_posthoc$statistic[1]`). This main effect was qualified by a significant D-level × Game Order interaction (`r play_anova_results$statistic$d_level_game_order`). Post-hoc analyses revealed that in the first game, High-D participants were significantly less willing to play again with their opponents compared to Low-D participants (`r play_d_by_game_posthoc$statistic[1]`), while no such difference existed in the second game (`r play_d_by_game_posthoc$statistic[2]`). Examining changes across games, Low-D participants showed a significant decrease in willingness to play again from the first to the second game (`r play_game_by_d_posthoc$statistic[2]`), while High-D participants maintained consistent ratings across games (`r play_game_by_d_posthoc$statistic[1]`).

### Trusting Ratings

For trust ratings, significant main effects were observed for D-level (`r trust_anova_results$statistic["d_level"]`), game order (`r trust_anova_results$statistic["game_order"]`), and opponent type (`r trust_anova_results$statistic["opponent_type"]`). These effects were qualified by a significant three-way interaction between D-level, game order, and opponent type (`r trust_anova_results$statistic$d_level_game_order_opponent_type`).

Post-hoc analyses revealed a complex pattern of trust perceptions. High-D participants rated Human-like opponents as significantly less trusting than Low-D participants in the first game (`r trust_d_by_game_opp_posthoc$statistic[1]`). In contrast, High-D participants rated Responsive opponents as significantly less trusting than Low-D participants in the second game (`r trust_d_by_game_opp_posthoc$statistic[4]`). Low-D participants showed a significant *increase* in trust ratings for Human-like opponents from the first to the second game (`r trust_game_by_d_opp_posthoc$statistic[2]`), while High-D participants showed a significant *decrease* in trust ratings for Responsive opponents from the first to the second game (`r trust_game_by_d_opp_posthoc$statistic[3]`). Additionally, High-D participants in the second game differentiated between opponent types, rating Human-like opponents as significantly more trusting than Responsive opponents (`r trust_opp_by_d_game_posthoc$statistic[3]`).

In summary, participants with higher Dark Factor scores demonstrated consistently more negative perceptions of their opponents, particularly regarding cooperation and trust. The pattern of results indicates that individual differences in Dark Factor traits influence not only the overall level of opponent ratings but also how these ratings change across repeated interactions and between different opponent types. Notably, Low-D participants showed greater sensitivity to game order, with more pronounced decreases in ratings from first to second game, while High-D participants demonstrated greater discrimination between opponent types in their trust ratings.



```{r}
create_rating_plots <- function(coop_emm, play_emm, trust_emm, y_limits = c(0, 8.5)) {
  
  # Helper function for significance stars
  get_stars <- function(p) {
    if (p < 0.001) {
      return("***")
    } else if (p < 0.01) {
      return("**")
    } else if (p < 0.05) {
      return("*")
    } else {
      return("")
    }
  }
  
  # Example p-values for each effect (adjust as needed)
  p_coop <- 0.0074
  p_play <- 0.0182
  p_trust_first <- 0.0182
  p_trust_second_volatile <- 0.0073
  p_trust_second_high <- 0.0127
  
  # Color/shape settings for High/Low D
  d_level_colors <- c("high_D" = "#E64B35", "low_D" = "#4DBBD5")
  d_level_shapes <- c("high_D" = 24,      # filled triangle
                      "low_D"  = 21)      # filled circle
  
  # Convert emmeans objects to data frames
  coop_data <- as.data.frame(coop_emm) %>% 
    mutate(opponent_type = "Overall", game_order = "Overall")
  play_data <- as.data.frame(play_emm) %>% 
    mutate(opponent_type = "Overall")
  trust_data <- as.data.frame(trust_emm)
  
  # Base plot: single legend for fill and shape
  base_plot <- function(data, plot_title) {
    ggplot(data, aes(x = opponent_type, y = emmean, 
                     fill = d_level, shape = d_level, color = d_level)) +
      geom_point(position = position_dodge(width = 0.6),
                 size = 3, color = "black") +
      geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), 
                    position = position_dodge(width = 0.6),
                    width = 0.2) +
      facet_wrap(~game_order) +
      #labs(title = NULL) +  # Remove title to match article style
      labs(title = plot_title)+
      theme_classic() +
      theme(
        # Single legend will be placed in coop_plot
        legend.position = "none",
        panel.grid.major.y = element_line(color = "gray90"),
        axis.text = element_text(size = 10, color = "black"),
        axis.title = element_text(size = 12),
        strip.background = element_rect(fill = "gray90"),
        plot.title       = element_text(size=12, face = "bold", hjust = 0.5),
        # Remove bold from facet titles:
        strip.text = element_text(size = 11)
      ) +
      # Combine fill & shape into one legend by giving them the same name, labels, and guide
      scale_fill_manual(
        name = "D-Factor Level",
        labels = c("High-D", "Low-D"),
        values = d_level_colors,
        guide = "legend"
      ) +
      scale_shape_manual(
        name = "D-Factor Level",
        labels = c("High-D", "Low-D"),
        values = d_level_shapes,
        guide = "legend"
      ) +
      scale_color_manual(
        name = "D-Factor Level",
        labels = c("High-D", "Low-D"),
        values = d_level_colors,
        guide = "legend"
      ) +
      scale_y_continuous(limits = y_limits)
  }
  
  # Create the three main plots
  coop_plot <- base_plot(coop_data, "Cooperative Ratings")
  play_plot <- base_plot(play_data, "Play Again Ratings")
  trust_plot <- base_plot(trust_data, "Trusting Ratings")
  
  # Minimal axis labeling
  coop_plot <- coop_plot + labs(x = NULL, y = "Mean Rating")
  play_plot <- play_plot + labs(x = "Opponent Type", y = NULL)
  trust_plot <- trust_plot + labs(x = NULL, y = NULL)
  
  # Move the legend inside the Cooperative Ratings panel
  coop_plot <- coop_plot + theme(legend.position = c(0.22, 0.85))
  
  # Add special formatting for trust plot to break the Human-like label into two lines
  trust_plot <- trust_plot + 
    scale_x_discrete(
      labels = function(x) {
        x <- gsub("Human-like", "Human\nlike", x)
        x <- gsub("Volatile", "Volatile", x)  # Keep other labels as is
        return(x)
      }
    )
  
  # Offset for horizontal bracket
  offset <- 0.15
  
  # Function to draw a significance bracket with downward ticks only
  draw_bracket <- function(x_center, y_top, star_label, facet_val = "Overall") {
    list(
      # Horizontal line
      geom_segment(data = data.frame(x = x_center - offset, 
                                     xend = x_center + offset, 
                                     y = y_top, yend = y_top,
                                     game_order = facet_val),
                   aes(x = x, xend = xend, y = y, yend = yend),
                   inherit.aes = FALSE),
      # Left vertical tick (downward only)
      geom_segment(data = data.frame(x = x_center - offset, 
                                     xend = x_center - offset, 
                                     y = y_top, yend = y_top - 0.1,
                                     game_order = facet_val),
                   aes(x = x, xend = xend, y = y, yend = yend),
                   inherit.aes = FALSE),
      # Right vertical tick (downward only)
      geom_segment(data = data.frame(x = x_center + offset, 
                                     xend = x_center + offset, 
                                     y = y_top, yend = y_top - 0.1,
                                     game_order = facet_val),
                   aes(x = x, xend = xend, y = y, yend = yend),
                   inherit.aes = FALSE),
      # Star text
      geom_text(data = data.frame(x = x_center, 
                                  y = y_top + 0.1, 
                                  label = star_label,
                                  game_order = facet_val),
                aes(x = x, y = y, label = label),
                inherit.aes = FALSE, size = 4)
    )
  }
  
  # 1. Cooperative Ratings significance
  coop_sig_y <- max(coop_data$emmean + coop_data$SE) + 0.3
  coop_plot <- coop_plot +
    draw_bracket(x_center = 1, 
                 y_top = coop_sig_y, 
                 star_label = get_stars(p_coop), 
                 facet_val = "Overall")
  
  # 2. Play Again Ratings significance (first game)
  play_first <- play_data %>% filter(game_order == "first game")
  if(nrow(play_first) > 0){
    play_sig_y <- max(play_first$emmean + play_first$SE) + 0.2
    play_plot <- play_plot +
      draw_bracket(x_center = 1, 
                   y_top = play_sig_y, 
                   star_label = get_stars(p_play),
                   facet_val = "first game")
  }
  
  # 3. Trusting Ratings significance
  # (a) first game, "Human-like"
  trust_first <- trust_data %>% filter(game_order == "first game", opponent_type == "Human-like")
  if(nrow(trust_first) > 0){
    trust_sig_y1 <- max(trust_first$emmean + trust_first$SE) + 0.3
    trust_plot <- trust_plot +
      list(
        # Horizontal bracket
        geom_segment(data = data.frame(x = 0.85, xend = 1.15, 
                                       y = trust_sig_y1, yend = trust_sig_y1,
                                       game_order = "first game", opponent_type = "Human-like"),
                     aes(x = x, xend = xend, y = y, yend = yend),
                     inherit.aes = FALSE),
        # Left vertical tick (down only)
        geom_segment(data = data.frame(x = 0.85, xend = 0.85, 
                                       y = trust_sig_y1, yend = trust_sig_y1 - 0.1,
                                       game_order = "first game", opponent_type = "Human-like"),
                     aes(x = x, xend = xend, y = y, yend = yend),
                     inherit.aes = FALSE),
        # Right vertical tick (down only)
        geom_segment(data = data.frame(x = 1.15, xend = 1.15, 
                                       y = trust_sig_y1, yend = trust_sig_y1 - 0.1,
                                       game_order = "first game", opponent_type = "Human-like"),
                     aes(x = x, xend = xend, y = y, yend = yend),
                     inherit.aes = FALSE),
        # Star
        geom_text(data = data.frame(x = 1.0, y = trust_sig_y1 + 0.1, 
                                    label = get_stars(p_trust_first),
                                    game_order = "first game", opponent_type = "Human-like"),
                  aes(x = x, y = y, label = label),
                  inherit.aes = FALSE, size = 4)
      )
  }
  
  # (b) second game, "Responsive"
  trust_second_volatile <- trust_data %>% filter(game_order == "second game", opponent_type == "Responsive")
  if(nrow(trust_second_volatile) > 0){
    trust_sig_y2 <- max(trust_second_volatile$emmean + trust_second_volatile$SE) + 0.3
    trust_plot <- trust_plot +
      list(
        geom_segment(data = data.frame(x = 1.85, xend = 2.15, 
                                       y = trust_sig_y2, yend = trust_sig_y2,
                                       game_order = "second game", opponent_type = "Responsive"),
                     aes(x = x, xend = xend, y = y, yend = yend),
                     inherit.aes = FALSE),
        geom_segment(data = data.frame(x = 1.85, xend = 1.85, 
                                       y = trust_sig_y2, yend = trust_sig_y2 - 0.1,
                                       game_order = "second game", opponent_type = "Responsive"),
                     aes(x = x, xend = xend, y = y, yend = yend),
                     inherit.aes = FALSE),
        geom_segment(data = data.frame(x = 2.15, xend = 2.15, 
                                       y = trust_sig_y2, yend = trust_sig_y2 - 0.1,
                                       game_order = "second game", opponent_type = "Responsive"),
                     aes(x = x, xend = xend, y = y, yend = yend),
                     inherit.aes = FALSE),
        geom_text(data = data.frame(x = 2.0, y = trust_sig_y2 + 0.1, 
                                    label = get_stars(p_trust_second_volatile),
                                    game_order = "second game", opponent_type = "Responsive"),
                  aes(x = x, y = y, label = label),
                  inherit.aes = FALSE, size = 4)
      )
  }
  
  # (c) second game, high_D difference
  trust_second_high <- trust_data %>% filter(game_order == "second game", d_level == "high_D")
  if(nrow(trust_second_high) > 0){
    trust_sig_y3 <- max(trust_second_high$emmean + trust_second_high$SE) + 0.3
    trust_plot <- trust_plot +
      list(
        geom_segment(data = data.frame(x = 0.7, xend = 1.7, 
                                       y = trust_sig_y3, yend = trust_sig_y3,
                                       game_order = "second game", d_level = "high_D"),
                     aes(x = x, xend = xend, y = y, yend = yend),
                     inherit.aes = FALSE),
        geom_segment(data = data.frame(x = 0.7, xend = 0.7, 
                                       y = trust_sig_y3, yend = trust_sig_y3 - 0.1,
                                       game_order = "second game", d_level = "high_D"),
                     aes(x = x, xend = xend, y = y, yend = yend),
                     inherit.aes = FALSE),
        geom_segment(data = data.frame(x = 1.7, xend = 1.7, 
                                       y = trust_sig_y3, yend = trust_sig_y3 - 0.1,
                                       game_order = "second game", d_level = "high_D"),
                     aes(x = x, xend = xend, y = y, yend = yend),
                     inherit.aes = FALSE),
        geom_text(data = data.frame(x = 1.2, y = trust_sig_y3 + 0.1, 
                                    label = get_stars(p_trust_second_high),
                                    game_order = "second game", d_level = "high_D"),
                  aes(x = x, y = y, label = label),
                  inherit.aes = FALSE, size = 4)
      )
  }
  
  # Add additional spacing for the axis text in trust_plot to accommodate line breaks
  trust_plot <- trust_plot + 
    theme(axis.text.x = element_text(lineheight = 0.8))
  
  # Add p-value legend inside the plot instead of as a caption
  trust_plot <- trust_plot + 
    annotate("text", x = 1.5, y = 3.8, size = 3,
             label = "* p < 0.05; ** p < 0.01; *** p < 0.001",
             hjust = 0.5)
  
  # Combine the three panels
  final_plot <- coop_plot + play_plot + trust_plot +
    plot_layout(ncol = 3)
  
  return(final_plot)
}

# Create plot
final_plot2 <- create_rating_plots(
  coop_emm = emmeans(coop_model_afex, ~ d_level),
  play_emm = emmeans(play_model_afex, ~ d_level | game_order),
  trust_emm = emmeans(trust_model_afex, ~ d_level * opponent_type | game_order),
  y_limits = c(4, 8.5)
)


```





```{r plotRatings,include=T, echo=FALSE, warning=FALSE, fig.pos='H', fig.cap="Averages and standard errors of the participants ratings of the opponent (y-axis) by each game and D-factor group for each opponent (x-axis). The left panel represents participants' perception of HMM cooperativeness, the right one indicates perceived HMM trust rating, and the middle panel shows the participants' willingness to play again with the same HMM. Cooperation, trust perception, and willingness to play again ratings were generally lower for the high DFP group.",   fig.width=10,fig.height=6, out.width="\\textwidth",  fig.align="center"}

final_plot2
```























## Debrief questions 

```{r}
library(tidyverse)

# Load your dataset (assuming it's already loaded as `final_data`)

# Summarize Turing test responses
turing_summary <- final_data %>%
  count(Turing.choice) %>%
  mutate(percentage = (n / sum(n)) * 100)

print(turing_summary)

# Plot results for visualization
ggplot(turing_summary, aes(x = Turing.choice, y = n, fill = Turing.choice)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_text(aes(label = paste0(round(percentage, 1), "%")), vjust = -0.5) +
  labs(title = "Distribution of Turing Test Responses",
       x = "Turing Test Response",
       y = "Count") +
  theme_minimal()

```

```{r}
# Create contingency table
turing_table <- final_data %>%
  distinct(playerId, .keep_all = TRUE) %>%
  with(table(d_level, Turing.choice))

# Chi-square test for overall difference
chi_result <- chisq.test(turing_table)
print(chi_result)

# Fisher's exact test (better for small samples)
fisher_result <- fisher.test(turing_table)
print(fisher_result)

# For comparing just Human vs Machine responses
human_machine <- final_data %>%
  distinct(playerId, .keep_all = TRUE) %>%
  filter(Turing.choice %in% c("Human", "Machine")) %>%
  with(table(d_level, Turing.choice))

human_machine_test <- fisher.test(human_machine)
print(human_machine_test)
```


Around 57% of participants either thought that they played against a human opponent or were not sure whether the investor was a human or a machine. There was no significant difference between the proportion of correct answers between High-D and Low-D groups.


```{r}
# library(httr)
# library(jsonlite)
# 
# # Function to query the OpenAI API
# analyze_with_llm <- function(text, prompt, api_key, model = "gpt-3.5-turbo") {
#   url <- "https://api.openai.com/v1/chat/completions"
#   
#   response <- POST(
#     url,
#     add_headers(
#       Authorization = paste("Bearer", api_key),
#       "Content-Type" = "application/json"
#     ),
#     body = toJSON(list(
#       model = model,
#       messages = list(
#         list(role = "system", content = prompt),
#         list(role = "user", content = text)
#       ),
#       temperature = 0  # deterministic output
#     ), auto_unbox = TRUE)
#   )
#   
#   result <- content(response, as = "parsed")
#   return(result$choices[[1]]$message$content)
# }
# 
# # Define your API key (securely store it, e.g., in environment variables)
# api_key <- Sys.getenv("OPENAI_API_KEY")
# 
# # Define a structured prompt
# strategy_prompt <- "
# You are a research assistant helping to analyse textual responses from participants of an economic trust game experiment. Classify the response into one or more of the following themes:
# 
# 1. Increased trust or generosity.
# 2. Decreased trust or cautiousness.
# 3. No change in behavior.
# 4. Reactive strategy based on opponent's behavior.
# 5. Random or no clear strategy mentioned.
# 6. Maximization of points explicitly mentioned.
# 7. Unclear or ambiguous reasoning.
# 
# Provide your classification as a numbered list based only on the themes above. Provide no additional explanation.
# "
# 
# # Apply the prompt to analyse the DescribeOther responses
# final_data$DescribeOther_Analysis <- sapply(
#   final_data$DescribeOther, 
#   analyze_with_llm, 
#   prompt = strategy_prompt, 
#   api_key = api_key
# )
# 
# # Inspect results
# head(final_data$DescribeOther_Analysis)

```




# Discussion


The present study investigated how the Dark Factor of Personality (D-factor) influences behavior in repeated trust games, focusing on trustworthiness patterns, strategic adaptation, and perception of counterparts. Our findings reveal nuanced relationships between dark personality traits and economic decision-making that both confirm and challenge existing theoretical frameworks.

Our results demonstrated significant behavioral differences between individuals with high and Low-D scores. High-D participants consistently returned lower proportions of investment compared to their Low-D counterparts, with this difference becoming particularly pronounced in later rounds of the game. This pattern aligns with the fundamental definition of the D-factor as "the general tendency to maximize one's utility at the expense of others, accompanied by beliefs that serve as justifications" [@Moshagen2018]. The lower return percentages directly translate to greater self-benefit at the investor's expense, supporting the construct validity of the D-factor in predicting economic behavior.
Interestingly, the timing of these differences suggests a strategic component to this behavior. The absence of significant differences in early rounds, followed by emerging disparities in later stages of interaction, indicates a possible exploitation pattern that develops over time and as participants learned the co-player's contingencies. This temporal dimension of trustworthiness aligns with prior research suggesting that dark personality traits may manifest most strongly after establishing a baseline relationship [@Jones2009]. This finding extends previous work on dark traits in one-shot economic games [@Zhao2015; @Thielmann2019] by demonstrating how these tendencies unfold over repeated interactions.

The significant interaction between D-factor, investment amount, round number, and opponent type reveals sophisticated strategic differences between High and Low-D individuals. When facing the predictable Human-like HMM opponent, High-D participants demonstrated a distinct pattern: they significantly decreased their returns over time for high-investment trials while maintaining relatively stable returns for low-investment trials. This selective exploitation strategy suggests a calculated approach to maximize gains while minimizing the risk of triggering retaliation from the investor.
This pattern is particularly significant because it represents a form of Machiavellian exploitation that targets situations of high trust (indicated by higher investments) rather than indiscriminate exploitation across all conditions. By selectively reducing reciprocity in high-stake interactions, High-D individuals effectively exploit the trust placed in them when the potential gains are greatest. This finding aligns with the conceptualization of Machiavellianism as involving strategic, long-term orientation to personal gain [@Jones2009] and supports previous research indicating that dark personality traits are associated with strategic rather than impulsive exploitation [@Gunnthorsdottir2002].
Notably, this strategic exploitation pattern was only observed with the more predictable Human-like HMM opponent, not with the Responsive opponent. This distinction suggests that High-D individuals may be particularly adept at identifying and exploiting predictable social dynamics, while showing more caution in Responsive or unpredictable social environments. This contextual sensitivity adds important nuance to our understanding of how dark personality traits manifest in economic decisions. An alternative, though not mutually exclusive, explanation could be that High-D individuals do not necessarily possess more sophisticated social intelligence, but rather a different learning model. For instance, they may be faster to abandon pro-social norms when they detect environmental predictability, a possibility that could be tested in future work by modeling individual learning rates. This distinction is important, as it reframes the behavior from one of pure strategic superiority to one of differential adaptation to social cues.


The significant four-way interaction involving investment, order of opponent presentation, D-factor, and round number further shows the adaptive nature of exploitation strategies. High-D participants who first encountered the stable (human-like) opponent showed decreasing returns over rounds for high and medium investments but maintained stable returns for low investments. In contrast, those who initially faced the Responsive opponent reduced returns for low and medium investments while maintaining returns for high investments.
This pattern suggests that High-D individuals rapidly adapt their exploitation strategies based on initial experiences. When first exposed to a predictable environment, they learn to exploit high-trust situations. Conversely, when first exposed to volatility, they adopt a more conservative strategy that maintains cooperation in high-stake interactions while reducing reciprocity in lower-risk situations. This adaptive learning demonstrates sophisticated social intelligence that may underlie the effectiveness of dark personality traits in navigating complex social environments.
Low-D participants, regardless of the order in which they faced opponents, maintained relatively stable return rates across rounds and investment levels, suggesting a more consistent approach to reciprocity that is less influenced by strategic considerations or learning effects. This stability in cooperative behavior may reflect stronger adherence to fairness norms and less susceptibility to exploitative tendencies.


The analysis of opponent ratings revealed that D-factor scores significantly influenced how participants perceived their counterparts. High-D participants consistently rated their opponents lower on cooperativeness, trustworthiness, and desirability for future interaction, regardless of the opponent's actual behavior. This negative perceptual bias is consistent with research suggesting that individuals with dark personality traits may have distorted social perceptions that justify exploitation [@Moshagen2018; @Zettler2021].
The interaction between D-factor, game order, and opponent type for trust ratings suggests complex differences in how high and Low-D individuals update their social perceptions based on experience. While Low-D participants showed increased trust in human-like opponents from first to second game, High-D participants showed decreased trust in Responsive opponents. This differential updating may reflect differences in attribution processes: Low-D individuals may attribute positive interactions to stable traits of their partner, while High-D individuals may be more sensitive to negative interactions and use them to justify subsequent exploitation.
These findings extend beyond economic behavior to suggest that the D-factor influences the entire process of social perception and decision-making. The negative bias in opponent evaluation may serve as a cognitive mechanism that facilitates exploitation by reducing empathic concern and moral constraints associated with harming a positively regarded other.


The analysis of final-round behavior, where participants knew there would be no further interactions, provides insight into purely self-interested tendencies without the strategic considerations of reputation building. In these last rounds, High-D participants returned significantly lower amounts than Low-D participants, both in absolute terms and as a percentage of investment. This finding represents a clear manifestation of the maximizing self-interest component of the D-factor when strategic constraints are removed.
The last-round effect essentially transforms the trust game into a dictator game, where participants can freely decide how much to return without fear of future consequences. The significant D-factor difference in this context aligns with previous research showing associations between the D-factor and selfish behavior in dictator games [@Hilbig2021]. The consistency across economic paradigms strengthens the conclusion that the D-factor represents a stable tendency toward self-maximization when social constraints are minimal.

A particularly interesting finding was that despite returning lower percentages, High-D participants did not achieve significantly higher total payoffs compared to Low-D participants. This seemingly paradoxical result can be explained by the adaptive nature of the HMM opponent, which reduced investments in response to lower returns from High-D participants. This dynamic illustrates how exploitative strategies may fail to maximize long-term gains in environments with responsive counterparts, as initial exploitation triggers defensive reactions that ultimately limit future opportunities for gain.
This outcome has important implications for understanding the evolutionary stability of dark personality traits. While the D-factor may confer advantages in certain one-shot interactions or where reputation effects are minimal, its effectiveness as a long-term strategy in repeated interactions with responsive partners appears limited. This aligns with theoretical accounts suggesting that dark personality traits may represent frequency-dependent strategies that are most beneficial when rare in a population [@Mealey1995], as widespread exploitation would trigger universal defensive responses that limit its effectiveness.

## Theoretical and practical implications
Our findings have several important implications for personality psychology and behavioral economics. First, they demonstrate that the D-factor, as a unifying construct of dark personality traits, provides meaningful predictive power for understanding trustworthiness in economic exchanges. The convergent patterns of exploitation, negative social perception, and self-maximization across different measures support the conceptual coherence of the D-factor construct.
Second, our results highlight the importance of considering the temporal dimension of trust and reciprocity. The emerging differences between high and Low-D participants over repeated interactions suggest that single-round economic games may underestimate the influence of personality traits on economic behavior. Future research should continue to examine how personality influences behavioral trajectories rather than just static decision points.
Third, the interaction between D-factor and opponent volatility provides insight into the contextual sensitivity of dark personality traits. The finding that High-D individuals modulate their exploitation strategies based on opponent predictability suggests sophisticated social intelligence rather than rigid antisocial tendencies. This nuance is important for developing more accurate models of how personality influences social decision-making across different environments.
Finally, our findings have practical implications for promoting cooperation in economic exchanges. The fact that High-D participants received lower investments over time indicates that exploitative strategies trigger defensive responses that ultimately limit opportunities for mutual gain. Interventions that highlight these long-term consequences might help redirect self-interested motivations toward more sustainable cooperative strategies.

## Limitations and future directions
Several limitations of the current study suggest directions for future research. First, while we observed clear behavioral differences between high and Low-D individuals, our design cannot determine which specific aspects of the D-factor (e.g., Machiavellianism, psychopathy, or narcissism) drive these effects. Future studies could include measures of these specific traits alongside the D-factor to examine their relative contributions, and potentially explore whether we can replciate these results when including participants with the whole range of D-scores. 
Second, our use of HMM opponents provided excellent experimental control but may limit ecological validity. Future research could examine D-factor influences in fully human interactions to capture the richer social dynamics of real-world trust building.
Finally, while we found significant differences in behavior and perception, we did not explore the underlying affective or cognitive processes that mediate these effects. Future studies could incorporate measures of empathy, moral disengagement, or social value orientation to understand how dark personality traits influence the subjective experience of economic exchanges. Furthermore, our participant sample, while diverse in country of origin, was recruited through an online platform and consisted primarily of individuals from Western countries. Future research should aim to replicate these findings in different cultural and socio-economic contexts to establish the broader generalizability of the D-factor's influence on strategic social behavior

# Conclusion
This study provides novel insights into how the Dark Factor of Personality influences behavior in repeated trust games. Our findings demonstrate that individuals with High-D scores exhibit systematic patterns of lower reciprocity that emerge most strongly in later rounds of interaction, particularly when facing predictable opponents and receiving high investments. These behavioral differences are accompanied by more negative perceptions of interaction partners, suggesting a comprehensive influence of dark personality traits on both social cognition and economic decision-making.
The sophistication of exploitation strategies—adapting to opponent type, investment level, and interaction history—indicates that dark personality traits may involve complex social intelligence rather than simple antisocial tendencies. However, the failure of these exploitative strategies to yield higher total payoffs highlights the self-limiting nature of exploitation in responsive social environments.
These findings bridge the gap between personality psychology and behavioral economics, demonstrating how stable personality traits manifest in dynamic economic exchanges. They extend previous research on dark personality traits by revealing how exploitation unfolds over time and varies across contexts. Future research should continue to explore the cognitive and affective mechanisms underlying these behavioral patterns and examine how interventions might promote cooperation even among individuals with stronger exploitative tendencies.
Understanding the relationship between the D-factor and trustworthiness has significant implications for promoting cooperative outcomes in economic and social interactions. By recognizing how dark personality traits influence trust dynamics, we can develop more effective strategies for fostering cooperation and limiting the social costs of exploitation.


\pagebreak

# References
